import { Bucket } from '@miniplex/bucket';
export * from '@miniplex/bucket';

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function () {};
      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

var Memoizer = /*#__PURE__*/function () {
  function Memoizer() {
    _classCallCheck(this, Memoizer);
    _defineProperty(this, "cache", new Map());
  }
  _createClass(Memoizer, [{
    key: "get",
    value: function get(key, predicate) {
      var value = this.cache.get(key);
      if (value === undefined) {
        this.cache.set(key, predicate);
        value = predicate;
      }
      return value;
    }
  }]);
  return Memoizer;
}();

function isArchetype(entity) {
  for (var _len = arguments.length, components = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    components[_key - 1] = arguments[_key];
  }
  return hasComponents.apply(void 0, [entity].concat(components));
}
function hasComponents(entity) {
  for (var _len2 = arguments.length, components = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    components[_key2 - 1] = arguments[_key2];
  }
  return components.every(function (c) {
    return entity[c] !== undefined;
  });
}
function hasAnyComponents(entity) {
  for (var _len3 = arguments.length, components = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    components[_key3 - 1] = arguments[_key3];
  }
  return components.some(function (c) {
    return entity[c] !== undefined;
  });
}
function hasNoComponents(entity) {
  for (var _len4 = arguments.length, components = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    components[_key4 - 1] = arguments[_key4];
  }
  return components.every(function (c) {
    return entity[c] === undefined;
  });
}

/* not */

var notCache = new Memoizer();
var not = function not(predicate) {
  return notCache.get(predicate, function (entity) {
    return !predicate(entity);
  });
};

var normalizeComponents = function normalizeComponents(components) {
  return _toConsumableArray(new Set(components.sort().filter(function (c) {
    return !!c && c !== "";
  })));
};

/* Archetype Queries */

var normalizeQuery = function normalizeQuery(query) {
  return {
    "with": query["with"] !== undefined ? normalizeComponents(query["with"]) : [],
    without: query.without !== undefined ? normalizeComponents(query.without) : []
  };
};
var queryCache = new Memoizer();
var memoizeQuery = function memoizeQuery(query) {
  var normalizedQuery = normalizeQuery(query);
  var key = JSON.stringify(normalizedQuery);
  return queryCache.get(key, normalizedQuery);
};

/**
 * An entity-aware bucket providing methods for creating
 * derived buckets, and tracking the buckets derived from it.
 */
var EntityBucket = /*#__PURE__*/function (_Bucket) {
  _inherits(EntityBucket, _Bucket);
  var _super = _createSuper(EntityBucket);
  function EntityBucket() {
    var _this;
    _classCallCheck(this, EntityBucket);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "buckets", new Set());
    return _this;
  }
  _createClass(EntityBucket, [{
    key: "wants",
    value:
    /**
     * Returns `true` if the given entity should be in this bucket. Child classes
     * should override this method to implement custom bucket logic.
     *
     * @param entity The entity to check for.
     * @returns `true` if this bucket wants the specified entity, `false` otherwise.
     */
    function wants(entity) {
      return true;
    }

    /**
     * Evaluates the given entity (`entity`) to check if it should be in this bucket or not.
     * The entity will be added or removed from this bucket as necessary.
     *
     * If you pass a second argument (`future`) into this function, it will be used
     * for these checks instead of the entity itself. This is useful in sutations
     * where you're about to make a destructive change to the entity, and want to
     * give archetype callbacks a chance to run with the entity intact before actually
     * making the change.
     *
     * @param entity The entity that is being evaluated.
     * @param future An optional future version of the entity that is used in the check.
     */
  }, {
    key: "evaluate",
    value: function evaluate(entity) {
      var future = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : entity;
      /* Accept or reject the entity */
      if (this.wants(future)) {
        this.add(entity);
      } else {
        this.remove(entity);
      }

      /* If the entity is still in this bucket, update derived buckets. */
      if (this.has(entity)) {
        var _iterator = _createForOfIteratorHelper(this.buckets),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var bucket = _step.value;
            bucket.evaluate(entity, future);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }
  }, {
    key: "where",
    value: function where(predicate) {
      var _this2 = this;
      var index = this.entities.length;
      var next = function next() {
        var value;
        do {
          value = _this2.entities[--index];
        } while (value && !predicate(value));
        return {
          value: value,
          done: index < 0
        };
      };
      return _defineProperty({}, Symbol.iterator, function () {
        return {
          next: next
        };
      });
    }

    /* with */
  }, {
    key: "with",
    value: function _with() {
      return this.archetype.apply(this, arguments);
    }

    /* without */
  }, {
    key: "without",
    value: function without() {
      for (var _len2 = arguments.length, props = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        props[_key2] = arguments[_key2];
      }
      return this.archetype({
        without: props
      });
    }

    /* Predicate form */
  }, {
    key: "archetype",
    value: /* Implementation */

    function archetype(query) {
      /* Handle the function form */
      if (typeof query === "function") {
        var _iterator2 = _createForOfIteratorHelper(this.buckets),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _bucket2 = _step2.value;
            if (_bucket2 instanceof PredicateBucket && _bucket2.predicate === query) {
              return _bucket2;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        var _bucket = new PredicateBucket(this, query);
        this.buckets.add(_bucket);
        return _bucket;
      }

      /* Handle the string form */
      if (_typeof(query) !== "object") {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          rest[_key3 - 1] = arguments[_key3];
        }
        return this.archetype({
          "with": [query].concat(rest)
        });
      }

      /* Find and return existing archetype bucket */
      var memoizedQuery = memoizeQuery(query);
      var _iterator3 = _createForOfIteratorHelper(this.buckets),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _bucket3 = _step3.value;
          if (_bucket3 instanceof ArchetypeBucket && _bucket3.query === memoizedQuery) {
            return _bucket3;
          }
        }

        /* Create a new bucket */
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      var bucket = new ArchetypeBucket(this, memoizedQuery);
      this.buckets.add(bucket);
      return bucket;
    }
  }]);
  return EntityBucket;
}(Bucket);
var DerivedEntityBucket = /*#__PURE__*/function (_EntityBucket) {
  _inherits(DerivedEntityBucket, _EntityBucket);
  var _super2 = _createSuper(DerivedEntityBucket);
  function DerivedEntityBucket(source) {
    var _this3;
    _classCallCheck(this, DerivedEntityBucket);
    _this3 = _super2.call(this);
    _this3.source = source;
    return _this3;
  }
  _createClass(DerivedEntityBucket, [{
    key: "startUpdating",
    value: function startUpdating() {
      var _this4 = this;
      this.source.onEntityAdded.add(function (e) {
        if (_this4.wants(e)) _this4.add(e);
      });
      this.source.onEntityRemoved.add(function (e) {
        _this4.remove(e);
      });
      this.update();
    }

    /**
     * Updates the contents of this bucket by iterating over the entities
     * in its source bucket, re-checking each one to see if it should be
     * in this bucket or not.
     */
  }, {
    key: "update",
    value: function update() {
      var _iterator4 = _createForOfIteratorHelper(this.source),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var entity = _step4.value;
          this.evaluate(entity);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
  }]);
  return DerivedEntityBucket;
}(EntityBucket);

/**
 * A bucket representing a subset of entities that satisfy
 * a given predicate.
 */
var PredicateBucket = /*#__PURE__*/function (_DerivedEntityBucket) {
  _inherits(PredicateBucket, _DerivedEntityBucket);
  var _super3 = _createSuper(PredicateBucket);
  function PredicateBucket(source, predicate) {
    var _this5;
    _classCallCheck(this, PredicateBucket);
    _this5 = _super3.call(this, source);
    _this5.source = source;
    _this5.predicate = predicate;
    _this5.startUpdating();
    return _this5;
  }
  _createClass(PredicateBucket, [{
    key: "wants",
    value: function wants(entity) {
      return this.predicate(entity);
    }
  }]);
  return PredicateBucket;
}(DerivedEntityBucket);

/**
 * A bucket representing a subset of entities that have a
 * specific set of components.
 */
var ArchetypeBucket = /*#__PURE__*/function (_DerivedEntityBucket2) {
  _inherits(ArchetypeBucket, _DerivedEntityBucket2);
  var _super4 = _createSuper(ArchetypeBucket);
  function ArchetypeBucket(source, query) {
    var _this6;
    _classCallCheck(this, ArchetypeBucket);
    _this6 = _super4.call(this, source);
    _this6.source = source;
    _this6.query = query;
    _this6.startUpdating();
    return _this6;
  }
  _createClass(ArchetypeBucket, [{
    key: "wants",
    value: function wants(entity) {
      return hasComponents.apply(void 0, [entity].concat(_toConsumableArray(this.query["with"] || []))) && hasNoComponents.apply(void 0, [entity].concat(_toConsumableArray(this.query.without || [])));
    }
  }]);
  return ArchetypeBucket;
}(DerivedEntityBucket);

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}

var World = /*#__PURE__*/function (_EntityBucket) {
  _inherits(World, _EntityBucket);
  var _super = _createSuper(World);
  function World() {
    var _this;
    var entities = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    _classCallCheck(this, World);
    _this = _super.call(this, entities);

    /* When entities are removed, also make sure to forget about their IDs. */
    _defineProperty(_assertThisInitialized(_this), "entityToId", new Map());
    _defineProperty(_assertThisInitialized(_this), "idToEntity", new Map());
    _defineProperty(_assertThisInitialized(_this), "nextId", 0);
    _this.onEntityRemoved.add(function (entity) {
      /* Remove the entity from the ID map */
      if (_this.entityToId.has(entity)) {
        var id = _this.entityToId.get(entity);
        _this.idToEntity["delete"](id);
        _this.entityToId["delete"](entity);
      }
    });
    return _this;
  }
  _createClass(World, [{
    key: "update",
    value: function (_update) {
      function update(_x, _x2, _x3) {
        return _update.apply(this, arguments);
      }
      update.toString = function () {
        return _update.toString();
      };
      return update;
    }(function (entity, update, value) {
      if (typeof update === "function") {
        var partial = update(entity);
        partial && Object.assign(entity, partial);
      } else if (typeof update === "string") {
        entity[update] = value;
      } else if (update) {
        Object.assign(entity, update);
      }

      /* If this world knows about the entity, notify any derived buckets about the change. */
      if (this.has(entity)) {
        this.evaluate(entity);
      }
      return entity;
    })
  }, {
    key: "addComponent",
    value: function addComponent(entity, component, value) {
      /* Return early if the entity already has the component. */
      if (entity[component] !== undefined) return;

      /* Set the component */
      entity[component] = value;

      /* Touch the entity, triggering re-checks of indices */
      if (this.has(entity)) {
        this.evaluate(entity);
      }
    }
  }, {
    key: "removeComponent",
    value: function removeComponent(entity, component) {
      /* Return early if the entity doesn't even have the component. */
      if (entity[component] === undefined) return;

      /* If this world knows about the entity, notify any derived buckets about the change. */
      if (this.has(entity)) {
        var future = _objectSpread2({}, entity);
        delete future[component];
        this.evaluate(entity, future);
      }

      /* Remove the component. */
      delete entity[component];
    }

    /* IDs */
  }, {
    key: "id",
    value: function id(entity) {
      /* We only ever want to generate IDs for entities that are actually in the world. */
      if (!this.has(entity)) return undefined;

      /* Lazily generate an ID. */
      if (!this.entityToId.has(entity)) {
        var id = this.nextId++;
        this.entityToId.set(entity, id);
        this.idToEntity.set(id, entity);
      }
      return this.entityToId.get(entity);
    }
  }, {
    key: "entity",
    value: function entity(id) {
      return this.idToEntity.get(id);
    }
  }]);
  return World;
}(EntityBucket);

export { ArchetypeBucket, DerivedEntityBucket, EntityBucket, PredicateBucket, World, hasAnyComponents, hasComponents, hasNoComponents, isArchetype, memoizeQuery, normalizeComponents, normalizeQuery, not };
