import { Bucket } from "@miniplex/bucket";
import { ArchetypeQuery, ArchetypeWithoutQuery, ArchetypeWithQuery, Predicate, With } from "./types";
/**
 * An entity-aware bucket providing methods for creating
 * derived buckets, and tracking the buckets derived from it.
 */
export declare class EntityBucket<E> extends Bucket<E> {
    buckets: Set<EntityBucket<any>>;
    /**
     * Returns `true` if the given entity should be in this bucket. Child classes
     * should override this method to implement custom bucket logic.
     *
     * @param entity The entity to check for.
     * @returns `true` if this bucket wants the specified entity, `false` otherwise.
     */
    wants(entity: any): entity is E;
    /**
     * Evaluates the given entity (`entity`) to check if it should be in this bucket or not.
     * The entity will be added or removed from this bucket as necessary.
     *
     * If you pass a second argument (`future`) into this function, it will be used
     * for these checks instead of the entity itself. This is useful in sutations
     * where you're about to make a destructive change to the entity, and want to
     * give archetype callbacks a chance to run with the entity intact before actually
     * making the change.
     *
     * @param entity The entity that is being evaluated.
     * @param future An optional future version of the entity that is used in the check.
     */
    evaluate(entity: E, future?: E): void;
    where<D extends E>(predicate: Predicate<E, D>): Iterable<D>;
    with<P extends keyof E>(...props: P[]): ArchetypeBucket<With<E, P>>;
    with<D extends With<E, any>>(...props: (keyof D)[]): ArchetypeBucket<D>;
    without<P extends keyof E>(...props: P[]): ArchetypeBucket<E>;
    without<D extends E>(...props: (keyof D)[]): ArchetypeBucket<D>;
    archetype<D extends E>(predicate: Predicate<E, D>): PredicateBucket<D>;
    archetype<P extends keyof E>(query: ArchetypeWithQuery<E, P>): ArchetypeBucket<With<E, P>>;
    archetype<P extends keyof E>(query: ArchetypeWithoutQuery<E>): ArchetypeBucket<E>;
    archetype<P extends keyof E>(query: ArchetypeQuery<E, P>): ArchetypeBucket<With<E, P>>;
    archetype<D extends With<E, any>>(query: ArchetypeQuery<E, any>): ArchetypeBucket<D>;
    archetype<P extends keyof E>(...components: P[]): ArchetypeBucket<With<E, P>>;
    archetype<D extends With<E, any>>(...components: (keyof D)[]): ArchetypeBucket<D>;
}
export declare abstract class DerivedEntityBucket<E> extends EntityBucket<E> {
    source: Bucket<any>;
    constructor(source: Bucket<any>);
    protected startUpdating(): void;
    /**
     * Updates the contents of this bucket by iterating over the entities
     * in its source bucket, re-checking each one to see if it should be
     * in this bucket or not.
     */
    update(): void;
}
/**
 * A bucket representing a subset of entities that satisfy
 * a given predicate.
 */
export declare class PredicateBucket<E> extends DerivedEntityBucket<E> {
    source: Bucket<any>;
    predicate: Predicate<E, E>;
    constructor(source: Bucket<any>, predicate: Predicate<E, E>);
    wants(entity: any): entity is E;
}
/**
 * A bucket representing a subset of entities that have a
 * specific set of components.
 */
export declare class ArchetypeBucket<E> extends DerivedEntityBucket<E> {
    source: Bucket<any>;
    query: ArchetypeQuery<E, keyof E>;
    constructor(source: Bucket<any>, query: ArchetypeQuery<E, keyof E>);
    wants(entity: any): entity is E;
}
