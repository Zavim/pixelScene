import { pipe } from 'fp-ts/function';
import { Color, Vector2, Vector3, Vector4, Matrix3, Matrix4 } from 'three';

function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

var Snippet = function Snippet(render) {
  /* Start with a randomized name. The compiler will assign a deterministic name in its prepare step. */
  var name = "uninitialized_snippet_".concat(Math.floor(Math.random() * 1000000));
  return {
    _: "Snippet",
    name: name,
    render: render,
    expression: render(name)
  };
};
var renameSnippet = function renameSnippet(snippet, name) {
  snippet.name = name;
  snippet.expression = snippet.render(name);
};
function isSnippet(x) {
  return x && x._ === "Snippet";
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}

var isPresent = function isPresent(p) {
  return !!p;
};
var concatenate = function concatenate() {
  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
    parts[_key] = arguments[_key];
  }
  return parts.flat(Infinity).filter(isPresent).join("\n");
};
var identifier = function identifier() {
  for (var _len2 = arguments.length, parts = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    parts[_key2] = arguments[_key2];
  }
  return parts.filter(isPresent).join("_").replace(/_{2,}/g, "_");
};
var statement = function statement() {
  for (var _len3 = arguments.length, parts = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    parts[_key3] = arguments[_key3];
  }
  return parts.filter(isPresent).join(" ") + ";";
};
var assignment = function assignment() {
  for (var _len4 = arguments.length, parts = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    parts[_key4] = arguments[_key4];
  }
  return statement(parts.join(" = "));
};
var block = function block() {
  for (var _len5 = arguments.length, parts = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    parts[_key5] = arguments[_key5];
  }
  return ["{", concatenate(parts).split("\n").map(function (line) {
    return "  " + line;
  }).join("\n"), "}"];
};
var sluggify = function sluggify(s) {
  return s.replace(/[^a-zA-Z0-9]/g, "_");
};

var _templateObject$2, _templateObject2$2, _templateObject3$2, _templateObject4$2, _templateObject5$2, _templateObject6$2, _templateObject7$2, _templateObject8$2, _templateObject9$1;
var unitAPI = function unitAPI(unit) {
  if (isUnitOfType(unit, "vec2")) {
    return {
      get x() {
        return Unit("float", $(_templateObject$2 || (_templateObject$2 = _taggedTemplateLiteral(["", ".x"])), unit));
      },
      get y() {
        return Unit("float", $(_templateObject2$2 || (_templateObject2$2 = _taggedTemplateLiteral(["", ".y"])), unit));
      }
    };
  }
  if (isUnitOfType(unit, "vec3")) {
    return {
      get x() {
        return Unit("float", $(_templateObject3$2 || (_templateObject3$2 = _taggedTemplateLiteral(["", ".x"])), unit));
      },
      get y() {
        return Unit("float", $(_templateObject4$2 || (_templateObject4$2 = _taggedTemplateLiteral(["", ".y"])), unit));
      },
      get z() {
        return Unit("float", $(_templateObject5$2 || (_templateObject5$2 = _taggedTemplateLiteral(["", ".z"])), unit));
      }
    };
  }
  if (isUnitOfType(unit, "vec4")) {
    return {
      get x() {
        return Unit("float", $(_templateObject6$2 || (_templateObject6$2 = _taggedTemplateLiteral(["", ".x"])), unit));
      },
      get y() {
        return Unit("float", $(_templateObject7$2 || (_templateObject7$2 = _taggedTemplateLiteral(["", ".y"])), unit));
      },
      get z() {
        return Unit("float", $(_templateObject8$2 || (_templateObject8$2 = _taggedTemplateLiteral(["", ".z"])), unit));
      },
      get w() {
        return Unit("float", $(_templateObject9$1 || (_templateObject9$1 = _taggedTemplateLiteral(["", ".w"])), unit));
      }
    };
  }
  return {};
};
var Unit = function Unit(type, value, _config) {
  var config = _objectSpread2({
    name: "Anonymous",
    type: type,
    value: value,
    varying: false,
    variableName: identifier("var", Math.floor(Math.random() * 1000000))
  }, _config);
  var state = {
    lastUpdateAt: undefined
  };
  var unit = {
    _: "Unit",
    _unitConfig: config,
    _unitState: state
  };
  return injectAPI(unit, unitAPI);
};
function isUnit(value) {
  return value && value._ === "Unit";
}
function isUnitOfType(value, type) {
  return isUnit(value) && value._unitConfig.type === type;
}
var isUnitInProgram = function isUnitInProgram(unit, program) {
  return [undefined, program].includes(unit._unitConfig.only);
};
var uniformName = function uniformName(unit) {
  var _unit$_unitConfig$uni;
  return (_unit$_unitConfig$uni = unit._unitConfig.uniformName) !== null && _unit$_unitConfig$uni !== void 0 ? _unit$_unitConfig$uni : "u_".concat(unit._unitConfig.variableName);
};
/**
 * Given a unit and an API factory function, pass the unit to the factory
 * function and inject its return value into the unit (as to not break
 * object references.)
 */
var injectAPI = function injectAPI(unit, factory) {
  var api = factory(unit);
  return Object.defineProperties(unit, Object.getOwnPropertyDescriptors(api));
};

var glslRepresentation = function glslRepresentation(value, typeHint) {
  if (value === undefined) return "";
  if (Array.isArray(value)) return value.map(function (v) {
    return glslRepresentation(v);
  }).join(", ");
  if (isUnit(value)) return value._unitConfig.uniform ? uniformName(value) : value._unitConfig.variableName;
  if (isExpression(value)) return value.render();
  if (isSnippet(value)) return value.name;
  if (typeof value === "string") return value;
  if (typeof value === "boolean") return value ? "true" : "false";
  if (typeof value === "number") {
    var s = value.toString();
    return typeHint === "int" ? s : s.match(/[.e]/) ? s : "".concat(s, ".0");
  }
  if (value instanceof Color) return "vec3(".concat(g(value.r), ", ").concat(g(value.g), ", ").concat(g(value.b), ")");
  if (value instanceof Vector2) return "vec2(".concat(g(value.x), ", ").concat(g(value.y), ")");
  if (value instanceof Vector3) return "vec3(".concat(g(value.x), ", ").concat(g(value.y), ", ").concat(g(value.z), ")");
  if (value instanceof Vector4) return "vec4(".concat(g(value.x), ", ").concat(g(value.y), ", ").concat(g(value.z), ", ").concat(g(value.w), ")");
  if (value instanceof Matrix3) return "mat3(".concat(value.toArray().map(function (n) {
    return g(n);
  }).join(", "), ")");
  if (value instanceof Matrix4) return "mat4(".concat(value.toArray().map(function (n) {
    return g(n);
  }).join(", "), ")");

  /* Fail */
  throw new Error("Could not render value to GLSL: ".concat(JSON.stringify(value)));
};
var g = glslRepresentation;

var zip = function zip(a, b) {
  return a.map(function (k, i) {
    return [k, b[i]];
  });
};
var glsl = function glsl(strings) {
  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values[_key - 1] = arguments[_key];
  }
  var render = function render() {
    return zip(strings, values.map(function (v) {
      return glslRepresentation(v);
    })).flat().join("");
  };
  return {
    _: "Expression",
    values: values,
    render: render,
    toString: render
  };
};

/** A shortcut for the `glsl` tagged template literal helper. */
var $ = glsl;
function isExpression(v) {
  return v && v._ === "Expression";
}

var glslType = function glslType(value) {
  if (isUnit(value)) return value._unitConfig.type;
  if (typeof value === "number") return "float";
  if (value instanceof Vector4) return "vec4";
  if (value instanceof Vector3) return "vec3";
  if (value instanceof Vector2) return "vec2";
  if (value instanceof Matrix3) return "mat3";
  if (value instanceof Matrix4) return "mat4";
  if (value instanceof Color) return "vec3";

  /* Fail */
  throw new Error("Could not render GLSL type for: ".concat(value));
};
var type = glslType;

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

var _templateObject$1, _templateObject2$1, _templateObject3$1, _templateObject4$1, _templateObject5$1, _templateObject6$1, _templateObject7$1, _templateObject8$1;

/* See: https://www.khronos.org/opengl/wiki/Data_Type_(GLSL) */

/**
 * The `CastableInput<T>` type describes the inputs that can be cast to a
 * `Unit<T>`. This type is used by the `Vec2`, `Vec3`, `Float` etc. unit
 * constructors, who will automatically cast the given values to the correct
 * type.
 */

/**
 * Returns an expression that casts the given values to a `float`.
 */
var $float = function $float() {
  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
    values[_key] = arguments[_key];
  }
  return $(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral(["float(", ")"])), values);
};

/**
 * Returns an expression that casts the given values to a `vec2`.
 */
var $vec2 = function $vec2() {
  for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    values[_key2] = arguments[_key2];
  }
  return $(_templateObject2$1 || (_templateObject2$1 = _taggedTemplateLiteral(["vec2(", ")"])), values);
};

/**
 * Returns an expression that casts the given values to a `vec3`.
 */
var $vec3 = function $vec3() {
  for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    values[_key3] = arguments[_key3];
  }
  return $(_templateObject3$1 || (_templateObject3$1 = _taggedTemplateLiteral(["vec3(", ")"])), values);
};

/**
 * Returns an expression that casts the given values to a `vec4`.
 */
var $vec4 = function $vec4() {
  for (var _len4 = arguments.length, values = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    values[_key4] = arguments[_key4];
  }
  return $(_templateObject4$1 || (_templateObject4$1 = _taggedTemplateLiteral(["vec4(", ")"])), values);
};

/**
 * Returns an expression that casts the given values to a `mat2`.
 */
var $mat2 = function $mat2() {
  for (var _len5 = arguments.length, values = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    values[_key5] = arguments[_key5];
  }
  return $(_templateObject5$1 || (_templateObject5$1 = _taggedTemplateLiteral(["mat2(", ")"])), values);
};

/**
 * Returns an expression that casts the given values to a `mat3`.
 */
var $mat3 = function $mat3() {
  for (var _len6 = arguments.length, values = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    values[_key6] = arguments[_key6];
  }
  return $(_templateObject6$1 || (_templateObject6$1 = _taggedTemplateLiteral(["mat3(", ")"])), values);
};

/**
 * Returns an expression that casts the given values to a `mat4`.
 */
var $mat4 = function $mat4() {
  for (var _len7 = arguments.length, values = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
    values[_key7] = arguments[_key7];
  }
  return $(_templateObject7$1 || (_templateObject7$1 = _taggedTemplateLiteral(["mat4(", ")"])), values);
};

/**
 * Returns an expression that swizzles the given value with the provided
 * swizzling components.
 *
 * @param v The input value to swizzle.
 * @param swizzle The swizzling components to use.
 * @returns An expression that swizzles the given value with the provided swizzle string.
 */
var $swizzle = function $swizzle(v, swizzle) {
  return $(_templateObject8$1 || (_templateObject8$1 = _taggedTemplateLiteral(["", ".", ""])), v, swizzle);
};
var unit = function unit(i, config) {
  return isUnit(i) ? i : Unit(type(i), i, config);
};

/**
 * Wraps an input value into a unit that is configured to use a varying.
 *
 * @param i Input value (unit, JS value or expression) to wrap in a varying unit.
 * @param config Optional extra configuration for the newly created unit.
 * @returns A new unit that wraps the given value and is configured to use a varying.
 */
var varying = function varying(i, config) {
  return Unit(type(i), i, _objectSpread2(_objectSpread2({}, config), {}, {
    varying: true
  }));
};
var makeUnitFactory = function makeUnitFactory(type) {
  return function (v, extras) {
    return Unit(type, v, extras);
  };
};
var makeCastableUnitFactory = function makeCastableUnitFactory(type, castFunction) {
  return function (v, extras) {
    return Unit(type, castFunction.apply(void 0, _toConsumableArray(Array.isArray(v) ? v : [v])), extras);
  };
};
var Float = makeCastableUnitFactory("float", $float);
var Int = makeUnitFactory("int");
var Bool = makeUnitFactory("bool");
var Vec2 = makeCastableUnitFactory("vec2", $vec2);
var Vec3 = makeCastableUnitFactory("vec3", $vec3);
var Vec4 = makeCastableUnitFactory("vec4", $vec4);
var Mat2 = makeCastableUnitFactory("mat2", $mat2);
var Mat3 = makeCastableUnitFactory("mat3", $mat3);
var Mat4 = makeCastableUnitFactory("mat4", $mat4);
var Master = function Master(extras) {
  return Bool(true, extras);
};

var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12;

/**
 * @internal
 */
var Operator = function Operator(name, operator) {
  return function (a, b) {
    return Unit(type(a), $(_templateObject || (_templateObject = _taggedTemplateLiteral(["", " ", " ", ""])), a, operator, b), {
      name: "".concat(name, " (").concat(type(a), ")")
    });
  };
};

/**
 * @internal
 */
var SingleArgumentFunction = function SingleArgumentFunction(name, functionName) {
  return function (a) {
    return Unit(type(a), $(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["", "(", ")"])), functionName, a), {
      name: "".concat(name, " (").concat(type(a), ")")
    });
  };
};

/**
 * A Shader Unit that adds two values and returns the result.
 */
var Add = Operator("Add", "+");

/**
 * A Shader Unit that subtracts two values and returns the result.
 */
var Sub = Operator("Subtract", "-");
var Subtract = Sub;

/**
 * A Shader Unit that multiplies two values and returns the result.
 */
var Mul = Operator("Multiply", "*");
var Multiply = Mul;

/**
 * A Shader Unit that divides two values and returns the result.
 */
var Div = Operator("Divide", "/");
var Divide = Div;

/**
 * Calculates the sine value of the input value.
 */
var Sin = SingleArgumentFunction("Sin", "sin");

/**
 * Calculates the cosine value of the input value.
 */
var Cos = SingleArgumentFunction("Cos", "cos");
var Tan = SingleArgumentFunction("Tan", "tan");
var Asin = SingleArgumentFunction("Asin", "asin");
var Acos = SingleArgumentFunction("Acos", "acos");
var Pow = function Pow(a, e) {
  return Unit(type(a), $(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["pow(", ", ", ")"])), a, e), {
    name: "Pow (".concat(type(a), ")")
  });
};
var Exp = SingleArgumentFunction("Exp", "exp");
var Exp2 = SingleArgumentFunction("Exp2", "exp2");
var Log = SingleArgumentFunction("Log", "log");
var Log2 = SingleArgumentFunction("Log2", "log2");
var Sqrt = SingleArgumentFunction("Sqrt", "sqrt");
var InverseSqrt = SingleArgumentFunction("InverseSqrt", "inversesqrt");

/**
 * A Shader Unit that finds the nearest integer less than or equal to the input value.
 * It is equivalent to the GLSL expression `trunc(a)`.
 *
 * @param a The input value.
 * @returns The truncated value of `a`.
 */
var Trunc = SingleArgumentFunction("Trunc", "trunc");

/**
 * A Shader Unit that finds the nearest integer to the input value.
 * It performs the GLSL expression `round(a)`.
 *
 * @param a The input value.
 * @returns The rounded value of `a`.
 */
var Round = SingleArgumentFunction("Round", "round");
var Fract = SingleArgumentFunction("Fract", "fract");
var Floor = SingleArgumentFunction("Floor", "floor");
var Ceil = SingleArgumentFunction("Ceil", "ceil");
var Abs = SingleArgumentFunction("Abs", "abs");
var Sign = SingleArgumentFunction("Sign", "sign");

/**
 * Converts the given value from degrees to radians.
 */
var Radians = SingleArgumentFunction("Radians", "radians");

/**
 * Converts the given value from radians to degrees.
 */
var Degrees = SingleArgumentFunction("Degrees", "degrees");
var Modulo = function Modulo(a, b) {
  return Unit(type(a), $(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["mod(", ", ", ")"])), a, b));
};
var Clamp = function Clamp(x, min, max) {
  return Unit(type(x), $(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["clamp(", ", ", ", ", ")"])), x, min, max), {
    name: "Clamp"
  });
};
var Clamp01 = function Clamp01(x) {
  return Clamp(x, 0, 1);
};
var Saturate = Clamp01;
var OneMinus = function OneMinus(v) {
  return Float(Sub(1, v), {
    name: "OneMinus"
  });
};

/**
 * Negates the value (equivalent to multiplying it with -1.)
 *
 * @param v Value to negate.
 * @returns A shader unit holding the negated value.
 */
var Negate = function Negate(v) {
  return Unit(type(v), Mul(v, -1), {
    name: "Negate"
  });
};

/**
 * Lerpy fun!
 *
 * @group Math
 * @param a
 * @param b
 * @param ratio
 * @returns
 */
var $lerp = function $lerp(a, b, ratio) {
  return $(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral(["mix(", ", ", ", ", ")"])), a, b, ratio);
};

/**
 * Performs linear interpolation between two values, and returns the result.
 *
 * Wraps the GLSL `mix` function.
 *
 * @param a The starting value of the interpolation.
 * @param b The ending value of the interpolation.
 * @param ratio The interpolation ratio.
 * @returns The interpolated value.
 */
var Lerp = function Lerp(a, b, ratio) {
  return Unit(type(a), $lerp(a, b, ratio), {
    name: "Mix"
  });
};
var $inverseLerp = function $inverseLerp(a, b, c) {
  return $(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral(["(", " - ", ") / (", " - ", ")"])), c, a, b, a);
};

/**
 * Performs inverse linear interpolation between two values, and returns the result.
 * Given three values `a`, `b`, and `c`, the result is the ratio of `c` between `a` and `b`.
 * Also see {@link Lerp}.
 *
 * @param a The starting value of the interpolation.
 * @param b The ending value of the interpolation.
 * @param c The value to find the interpolation ratio of.
 * @returns The interpolation ratio of `c` between `a` and `b`.
 */
var InverseLerp = function InverseLerp(a, b, c) {
  return Unit(type(a), $inverseLerp(a, b, c), {
    name: "Inverse Lerp"
  });
};
var Mix = Lerp;

/**
 * Given an `edge` value and an input value `v`, returns 0 if the value is less than the
 * edge, and 1 if the value is greater than or equal to the edge.
 *
 * Wraps the GLSL `step` function.
 *
 * @example
 * Moooooooo
 *
 * ```jsx
 * Step(0.5, 0.25, f)
 * ```
 *
 * @param edge The edge value.
 * @param v The value to test.
 * @returns The result of the step function.
 */
var Step = function Step(edge, v) {
  return Float($(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral(["step(", ", ", ")"])), edge, v), {
    name: "Step"
  });
};

/**
 * Performs a Hermite interpolation between two values, and returns the result.
 *
 * Wraps the GLSL `smoothstep` function.
 *
 * @param min The lower edge of the Hermite einterpolation.
 * @param max The upper edge of the Hermite interpolation.
 * @param v The source value for the interpolation.
 * @returns The result of the Hermite interpolation.
 */
var Smoothstep = function Smoothstep(min, max, v) {
  return Float($(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral(["smoothstep(", ", ", ", ", ")"])), min, max, v), {
    name: "Smoothstep"
  });
};
var $remap = function $remap(value, inMin, inMax, outMin, outMax) {
  return $(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral(["mix(", ", ", ", ", ")"])), outMin, outMax, $inverseLerp(inMin, inMax, value));
};
var Remap = function Remap(value, inMin, inMax, outMin, outMax) {
  return Unit(type(value), $remap(value, inMin, inMax, outMin, outMax));
};
var NormalizePlusMinusOne = function NormalizePlusMinusOne(f) {
  return Remap(f, -1, 1, 0, 1);
};
var Min = function Min(a, b) {
  return Unit(type(a), $(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral(["min(", ", ", ")"])), a, b));
};
var Max = function Max(a, b) {
  return Unit(type(a), $(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral(["max(", ", ", ")"])), a, b));
};

/**
 * Applies scaling (multiplication) and offset (addition) to a given value.
 *
 * @param v The value to scale and offset.
 * @param scale The scale to apply. (Default: 1)
 * @param offset The offset to apply. (Default: 0)
 * @returns A unit holding the scaled and offset value.
 */
var ScaleAndOffset = function ScaleAndOffset(v) {
  var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return Unit(type(v), pipe(v, function (v) {
    return Mul(v, scale);
  }, function (v) {
    return Add(v, offset);
  }), {
    name: "Scale and Offset"
  });
};

export { $, Add as A, Bool as B, identifier as C, Div as D, sluggify as E, Float as F, renameSnippet as G, concatenate as H, Int as I, glslType as J, SingleArgumentFunction as K, Lerp as L, Mix as M, Subtract as N, Operator as O, Pow as P, Multiply as Q, Divide as R, Sub as S, Sin as T, Unit as U, Vec3 as V, Cos as W, Tan as X, Asin as Y, Acos as Z, _taggedTemplateLiteral as _, Mul as a, Exp as a0, Exp2 as a1, Log as a2, Log2 as a3, Sqrt as a4, InverseSqrt as a5, Trunc as a6, Round as a7, Fract as a8, Floor as a9, unit as aA, varying as aB, Mat2 as aC, Ceil as aa, Sign as ab, Radians as ac, Degrees as ad, Modulo as ae, Clamp as af, Clamp01 as ag, OneMinus as ah, Negate as ai, $lerp as aj, $inverseLerp as ak, InverseLerp as al, Step as am, $remap as an, Remap as ao, NormalizePlusMinusOne as ap, Min as aq, Max as ar, ScaleAndOffset as as, $float as at, $vec2 as au, $vec3 as av, $vec4 as aw, $mat2 as ax, $mat4 as ay, $swizzle as az, Vec2 as b, Mat4 as c, _objectSpread2 as d, Abs as e, Saturate as f, Smoothstep as g, Master as h, injectAPI as i, Snippet as j, glsl as k, Mat3 as l, $mat3 as m, Vec4 as n, _unsupportedIterableToArray as o, isUnit as p, isExpression as q, isSnippet as r, _defineProperty as s, type as t, uniformName as u, isUnitInProgram as v, statement as w, glslRepresentation as x, block as y, assignment as z };
