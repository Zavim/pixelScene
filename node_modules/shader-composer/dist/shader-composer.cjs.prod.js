'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var math = require('./math-8b84aa67.cjs.prod.js');
var _function = require('fp-ts/function');
var three = require('three');

var _templateObject$9, _templateObject2$7;

// "Note that modelViewMatrix is not set when rendering an instanced model"
// https://threejs.org/docs/#api/en/renderers/webgl/WebGLProgram
var $localToViewSpace = function $localToViewSpace(v) {
  return math.$(_templateObject$9 || (_templateObject$9 = math._taggedTemplateLiteral(["\n  vec3(\n    ", " *\n    ", " *\n    #ifdef USE_INSTANCING\n    instanceMatrix *\n    #endif\n    vec4(", ", 1.0)\n  )\n"])), ViewMatrix, ModelMatrix, v);
};
var $localToWorldSpace = function $localToWorldSpace(v) {
  return math.$(_templateObject2$7 || (_templateObject2$7 = math._taggedTemplateLiteral(["\n  vec3(\n    ", " *\n    #ifdef USE_INSTANCING\n    instanceMatrix *\n    #endif\n    vec4(", ", 1.0)\n  )\n"])), ModelMatrix, v);
};

/**
 * Converts the given position vector (which is assumed to be in local space)
 * to view space.
 */
var LocalToViewSpace = function LocalToViewSpace(position) {
  return math.Vec3($localToViewSpace(position));
};

/**
 * Converts the given position vector (which is assumed to be in local space)
 * to world space.
 */
var LocalToWorldSpace = function LocalToWorldSpace(position) {
  return math.Vec3($localToWorldSpace(position));
};

var _templateObject$8, _templateObject2$6, _templateObject3$5, _templateObject4$4, _templateObject5$2, _templateObject6$2, _templateObject7$2, _templateObject8$2, _templateObject9$1, _templateObject10$1, _templateObject11$1, _templateObject12$1, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18, _templateObject19;

/**
 * Returns the current fragment's on-screen coordinate.
 */
var FragmentCoordinate = math.Vec2(math.$(_templateObject$8 || (_templateObject$8 = math._taggedTemplateLiteral(["gl_FragCoord.xy"]))), {
  name: "Fragment Coordinate",
  only: "fragment"
});

/**
 * In instanced rendering, will return the instance ID.
 * Wraps the `gl_InstanceID` GLSL built-in.
 */
var InstanceID = math.Int(math.$(_templateObject2$6 || (_templateObject2$6 = math._taggedTemplateLiteral(["gl_InstanceID"]))), {
  name: "Instance ID",
  varying: "flat"
});

/**
 * Returns the verte ID.
 * Wraps the `gl_VertexID` GLSL built-in.
 *
 * Note: available in vertex shader only!
 */
var VertexID = math.Int(math.$(_templateObject3$5 || (_templateObject3$5 = math._taggedTemplateLiteral(["gl_VertexID"]))), {
  name: "Vertex ID",
  only: "vertex"
});
var CameraPosition = math.Vec3(math.$(_templateObject4$4 || (_templateObject4$4 = math._taggedTemplateLiteral(["cameraPosition"]))), {
  name: "Camera Position"
});
var ViewMatrix = math.Mat4(math.$(_templateObject5$2 || (_templateObject5$2 = math._taggedTemplateLiteral(["viewMatrix"]))), {
  name: "View Matrix"
});
var ModelMatrix = math.Mat4(math.$(_templateObject6$2 || (_templateObject6$2 = math._taggedTemplateLiteral(["modelMatrix"]))), {
  name: "Model Matrix"
});
var ModelViewMatrix = math.Mat4(math.$(_templateObject7$2 || (_templateObject7$2 = math._taggedTemplateLiteral(["modelViewMatrix"]))), {
  name: "ModelView Matrix"
});
var NormalMatrix = math.Mat4(math.$(_templateObject8$2 || (_templateObject8$2 = math._taggedTemplateLiteral(["normalMatrix"]))), {
  name: "Normal Matrix"
});
var ProjectionMatrix = math.Mat4(math.$(_templateObject9$1 || (_templateObject9$1 = math._taggedTemplateLiteral(["projectionMatrix"]))), {
  name: "Projection Matrix"
});

/**
 * Returns true if instanced rendering is enabled, false if it is not.
 */
var UsingInstancing = math.Bool(math.$(_templateObject10$1 || (_templateObject10$1 = math._taggedTemplateLiteral(["\n  #ifdef USE_INSTANCING\n    true\n  #else\n    false\n  #endif\n"]))));

/**
 * Returns the instance matrix. Please note that this is only available when
 * instanced rendering is enabled.
 */
var InstanceMatrix = math.Mat4(math.$(_templateObject11$1 || (_templateObject11$1 = math._taggedTemplateLiteral(["instanceMatrix"]))), {
  name: "Instance Matrix",
  only: "vertex"
});
var UV = math.Vec2(math.$(_templateObject12$1 || (_templateObject12$1 = math._taggedTemplateLiteral(["uv"]))), {
  name: "UV",
  varying: true
});
var Vec3WithSpaceConversions = function Vec3WithSpaceConversions(expr, name) {
  return math.injectAPI(math.Vec3(expr, {
    name: name,
    varying: true
  }), function (unit) {
    return {
      get world() {
        return math.Vec3($localToWorldSpace(unit), {
          varying: true,
          name: "".concat(name, " (World Space)")
        });
      },
      get view() {
        return math.Vec3($localToViewSpace(unit), {
          varying: true,
          name: "".concat(name, " (View Space)")
        });
      }
    };
  });
};
var VertexPosition = Vec3WithSpaceConversions(math.$(_templateObject13 || (_templateObject13 = math._taggedTemplateLiteral(["position"]))), "Vertex Position");
var VertexNormal = Vec3WithSpaceConversions(math.$(_templateObject14 || (_templateObject14 = math._taggedTemplateLiteral(["normal"]))), "Vertex Normal");
var ViewDirection = math.Vec3(math.$(_templateObject15 || (_templateObject15 = math._taggedTemplateLiteral(["vec3(-", "[0][2], -", "[1][2], -", "[2][2])"])), ViewMatrix, ViewMatrix, ViewMatrix), {
  varying: true,
  name: "View Direction"
});
var IsFrontFacing = math.Bool(math.$(_templateObject16 || (_templateObject16 = math._taggedTemplateLiteral(["gl_FrontFacing"]))), {
  only: "fragment"
});
var Attribute = function Attribute(type, name) {
  return math.Unit(type, math.$(_templateObject17 || (_templateObject17 = math._taggedTemplateLiteral(["", ""])), name), {
    name: "Attribute: ".concat(name),
    varying: true,
    vertex: {
      header: math.$(_templateObject18 || (_templateObject18 = math._taggedTemplateLiteral(["attribute ", " ", ";"])), type, name)
    }
  });
};
var UniformUnit = function UniformUnit(type, initialValue, extras) {
  var uniform = {
    value: initialValue
  };

  /* Create the actual unit that represents the uniform. */
  var unit = math.Unit(type, undefined, math._objectSpread2(math._objectSpread2({
    name: "Uniform (".concat(type, ")")
  }, extras), {}, {
    uniform: uniform
  }));

  /* Return the unit with some API bits mixed in. */
  return math.injectAPI(unit, function () {
    return {
      set value(v) {
        uniform.value = v;
      },
      get value() {
        return uniform.value;
      }
    };
  });
};

/**
 * Provides a uniform unit holding a representation of time. The time value
 * stored is not an absolute time, so multiple instances of this unit will not
 * be synchronized. If you require synchronization, please either reuse the
 * same instance of this unit, or use `GlobalTime` instead.
 *
 * @param initial The initial time value to start with. (Default: 0)
 */
var Time = function Time() {
  var initial = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var uniform = UniformUnit("float", initial, {
    name: "Time Uniform",
    update: function update(dt) {
      uniform.value += dt;
    }
  });
  return uniform;
};

/**
 * A global time uniform unit that can be safely used across multiple shaders,
 * wherever synchronization is required,
 * and as a default value for `time` inputs of other unit implementations, to prevent
 * shaders from being spammed by multiple uniforms all holding different
 * representations of time.
 */
var GlobalTime = Time();
var Resolution = UniformUnit("vec2", new three.Vector2(0, 0), {
  name: "Current Render Resolution",
  update: function update(dt, camera, scene, gl) {
    Resolution.value.x = gl.domElement.width;
    Resolution.value.y = gl.domElement.height;
  }
});
var CameraNear = UniformUnit("float", 0, {
  name: "Camera Near Plane",
  update: function update(_, camera) {
    if (camera instanceof three.PerspectiveCamera) {
      CameraNear.value = camera.near;
    }
  }
});
var CameraFar = UniformUnit("float", 0, {
  name: "Camera Far Plane",
  update: function update(_, camera) {
    if (camera instanceof three.PerspectiveCamera) {
      CameraFar.value = camera.far;
    }
  }
});
var ScreenUV = math.Vec2(math.$(_templateObject19 || (_templateObject19 = math._taggedTemplateLiteral(["", " / ", ""])), FragmentCoordinate, Resolution), {
  name: "Screen UV"
});

var _templateObject$7, _templateObject2$5, _templateObject3$4, _templateObject4$3, _templateObject5$1, _templateObject6$1, _templateObject7$1, _templateObject8$1;
var $orthogonal = function $orthogonal(v) {
  return math.$ /*glsl*/(_templateObject$7 || (_templateObject$7 = math._taggedTemplateLiteral(["\n  normalize(\n    abs(", ".x) > abs(", ".z)\n    ? vec3( -", ".y, ", ".x, 0.0 )\n    : vec3( 0.0, -", ".z, ", ".y)\n  )"])), v, v, v, v, v, v);
};

/**
 * Returns the normalized (unit length) version of a given vector.
 *
 * @param a The vec2/3/4 input value to normalize.
 * @returns A new Shader Unit containing the normalized value of `a`.
 */
var Normalize = function Normalize(a) {
  return math.Unit(math.type(a), math.$(_templateObject2$5 || (_templateObject2$5 = math._taggedTemplateLiteral(["normalize(", ")"])), a), {
    name: "Normalize"
  });
};
var Cross = function Cross(a, b) {
  return math.Vec3(math.$(_templateObject3$4 || (_templateObject3$4 = math._taggedTemplateLiteral(["cross(", ", ", ")"])), a, b), {
    name: "Cross Product"
  });
};
var Dot = function Dot(a, b) {
  return math.Float(math.$(_templateObject4$3 || (_templateObject4$3 = math._taggedTemplateLiteral(["dot(", ", ", ")"])), a, b), {
    name: "Dot Product"
  });
};
var Tangent = function Tangent(v) {
  return math.Vec3($orthogonal(v), {
    name: "Tangent"
  });
};
var Bitangent = function Bitangent(p, t) {
  return math.Vec3(Normalize(Cross(p, t)), {
    name: "Bitangent"
  });
};
var Distance = function Distance(a, b) {
  return math.Float(math.$(_templateObject5$1 || (_templateObject5$1 = math._taggedTemplateLiteral(["distance(", ", ", ")"])), a, b), {
    name: "Distance"
  });
};
var Length = function Length(a) {
  return math.Float(math.$(_templateObject6$1 || (_templateObject6$1 = math._taggedTemplateLiteral(["length(", ")"])), a), {
    name: "Length"
  });
};
var Reflect = function Reflect(vector, normal) {
  return math.Unit(math.type(vector), math.$(_templateObject7$1 || (_templateObject7$1 = math._taggedTemplateLiteral(["reflect(", ", ", ")"])), vector, normal), {
    name: "Reflect (".concat(math.type(vector), ")")
  });
};
var Refract = function Refract(vector, normal, eta) {
  return math.Unit(math.type(vector), math.$(_templateObject8$1 || (_templateObject8$1 = math._taggedTemplateLiteral(["refract(", ", ", ", ", ")"])), vector, normal, eta), {
    name: "Refract (".concat(math.type(vector), ")")
  });
};

var _templateObject$6;
/**
 * A Shader Unit that calculates the fresnel effect.
 *
 * @param param0.normal The normal of the surface. Defaults to {@link VertexNormal}.
 * @param param0.alpha The alpha value of the fresnel effect. Defaults to 1.
 * @param param0.bias The bias of the fresnel effect. Defaults to 0.
 * @param param0.intensity The intensity of the fresnel effect. Defaults to 1.
 * @param param0.power The power of the fresnel effect. Defaults to 1.
 * @returns A shader unit holding the fresnel value.
 */
var Fresnel = function Fresnel() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    _ref$normal = _ref.normal,
    normal = _ref$normal === void 0 ? VertexNormal.world : _ref$normal,
    _ref$bias = _ref.bias,
    bias = _ref$bias === void 0 ? 0 : _ref$bias,
    _ref$intensity = _ref.intensity,
    intensity = _ref$intensity === void 0 ? 1 : _ref$intensity,
    _ref$power = _ref.power,
    power = _ref$power === void 0 ? 2 : _ref$power,
    _ref$factor = _ref.factor,
    factor = _ref$factor === void 0 ? 1 : _ref$factor;
  return math.Float(_function.pipe(normal, function (v) {
    return Normalize(v);
  }, function (v) {
    return Dot(ViewDirection, v);
  }, function (v) {
    return math.Add(factor, v);
  }, function (v) {
    return math.Abs(v);
  }, function (v) {
    return math.Pow(v, power);
  }, function (v) {
    return math.Mul(v, intensity);
  }, function (v) {
    return math.Add(v, bias);
  }, function (v) {
    return math.Saturate(v);
  }), {
    name: "Fresnel"
  });
};
/**
 * A Shader Unit that returns the value of a gradient at a specified position.
 *
 * @param f The position within the gradient.
 * @param stops A configuration of value stops making up the gradient. See {@link GradientStops}.
 * @returns A shader unit holding the gradient value at the specified position.
 */
var Gradient = function Gradient(f) {
  for (var _len = arguments.length, stops = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    stops[_key - 1] = arguments[_key];
  }
  var color = stops[0][0];
  for (var i = 1; i < stops.length; i++) {
    var stop = stops[i];
    var previous = stops[i - 1];
    color = math.Lerp(color, stop[0], math.Smoothstep(previous[1], stop[1], f));
  }
  return color;
};
var Luminance = function Luminance(color) {
  return math.Float(math.$(_templateObject$6 || (_templateObject$6 = math._taggedTemplateLiteral(["luminance(", ")"])), color));
};

var _templateObject$5, _templateObject2$4;
var If = function If(expression, then, else_) {
  return math.Unit(math.type(then), math.$(_templateObject$5 || (_templateObject$5 = math._taggedTemplateLiteral(["(", " ? ", " : ", ")"])), expression, then, else_));
};
var GreaterOrEqual = function GreaterOrEqual(a, b) {
  return math.Bool(math.$(_templateObject2$4 || (_templateObject2$4 = math._taggedTemplateLiteral(["(", " >= ", ")"])), a, b));
};

var _templateObject$4, _templateObject2$3, _templateObject3$3, _templateObject4$2, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12;
var ShaderMaterialMaster = function ShaderMaterialMaster() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    _ref$color = _ref.color,
    color = _ref$color === void 0 ? new three.Color("red") : _ref$color,
    _ref$alpha = _ref.alpha,
    alpha = _ref$alpha === void 0 ? 1 : _ref$alpha,
    _ref$position = _ref.position,
    position = _ref$position === void 0 ? VertexPosition : _ref$position;
  return math.Master({
    name: "ShaderMaterial Master",
    vertex: {
      body: math.$(_templateObject$4 || (_templateObject$4 = math._taggedTemplateLiteral(["\n\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(", ", 1.0);\n\t\t\t"])), position)
    },
    fragment: {
      body: math.$(_templateObject2$3 || (_templateObject2$3 = math._taggedTemplateLiteral(["\n\t\t\t\tgl_FragColor = vec4(", ", ", ");\n\t\t\t"])), color, alpha)
    }
  });
};
var CustomShaderMaterialMaster = function CustomShaderMaterialMaster() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    position = _ref2.position,
    normal = _ref2.normal,
    diffuseColor = _ref2.diffuseColor,
    emissiveColor = _ref2.emissiveColor,
    fragColor = _ref2.fragColor,
    roughness = _ref2.roughness,
    metalness = _ref2.metalness,
    alpha = _ref2.alpha;
  return math.Master({
    name: "CustomShaderMaterial Master",
    vertex: {
      body: math.$(_templateObject3$3 || (_templateObject3$3 = math._taggedTemplateLiteral(["\n\t\t\t\t", "\n\t\t\t\t", "\n\t\t\t"])), position !== undefined ? math.$(_templateObject4$2 || (_templateObject4$2 = math._taggedTemplateLiteral(["csm_Position.xyz = ", ";"])), position) : "", normal !== undefined ? math.$(_templateObject5 || (_templateObject5 = math._taggedTemplateLiteral(["csm_Normal = ", ";"])), normal) : "")
    },
    fragment: {
      body: math.$(_templateObject6 || (_templateObject6 = math._taggedTemplateLiteral(["\n  \t\t\t", "\n\t\t\t\t", "\n\t\t\t\t", "\n\t\t\t\t", "\n\n        #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\n          ", "\n          ", "\n        #endif\n\t\t\t"])), alpha !== undefined ? math.$(_templateObject7 || (_templateObject7 = math._taggedTemplateLiteral(["csm_DiffuseColor.a = ", ";"])), alpha) : "", diffuseColor !== undefined ? math.$(_templateObject8 || (_templateObject8 = math._taggedTemplateLiteral(["csm_DiffuseColor.rgb = ", ";"])), diffuseColor) : "", emissiveColor !== undefined ? math.$(_templateObject9 || (_templateObject9 = math._taggedTemplateLiteral(["csm_Emissive = ", ";"])), emissiveColor) : "", fragColor !== undefined ? math.$(_templateObject10 || (_templateObject10 = math._taggedTemplateLiteral(["csm_FragColor = vec4(", ", ", ");"])), fragColor, alpha) : "", roughness !== undefined ? math.$(_templateObject11 || (_templateObject11 = math._taggedTemplateLiteral(["csm_Roughness = ", ";"])), roughness) : "", metalness !== undefined ? math.$(_templateObject12 || (_templateObject12 = math._taggedTemplateLiteral(["csm_Metalness = ", ";"])), metalness) : "")
    }
  });
};

var _templateObject$3, _templateObject2$2, _templateObject3$2, _templateObject4$1;
var rotation3d = math.Snippet(function (name) {
  return math.glsl(_templateObject$3 || (_templateObject$3 = math._taggedTemplateLiteral(["\n\t\tmat4 ", "(vec3 axis, float angle) {\n\t\t\taxis = normalize(axis);\n\t\t\tfloat s = sin(angle);\n\t\t\tfloat c = cos(angle);\n\t\t\tfloat oc = 1.0 - c;\n\t\t\treturn mat4(\n\t\t\t\toc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n\t\t\t\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n\t\t\t\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n\t\t\t\t0.0,                                0.0,                                0.0,                                1.0\n\t\t\t);\n\t\t}\n\t"])), name);
});
var rotation3dX = math.Snippet(function (name) {
  return math.glsl(_templateObject2$2 || (_templateObject2$2 = math._taggedTemplateLiteral(["\n\t\tmat3 ", "(float angle) {\n\t\t\tfloat s = sin(angle);\n\t\t\tfloat c = cos(angle);\n\t\t\treturn mat3(\n\t\t\t\t1.0, 0.0, 0.0,\n\t\t\t\t0.0, c, s,\n\t\t\t\t0.0, -s, c\n\t\t\t);\n\t\t}\n\t"])), name);
});
var rotation3dY = math.Snippet(function (name) {
  return math.glsl(_templateObject3$2 || (_templateObject3$2 = math._taggedTemplateLiteral(["\n\t\tmat3 ", "(float angle) {\n\t\t\tfloat s = sin(angle);\n\t\t\tfloat c = cos(angle);\n\t\t\n\t\t\treturn mat3(\n\t\t\t\tc, 0.0, -s,\n\t\t\t\t0.0, 1.0, 0.0,\n\t\t\t\ts, 0.0, c\n\t\t\t);\n\t\t}\n\t"])), name);
});
var rotation3dZ = math.Snippet(function (name) {
  return math.glsl(_templateObject4$1 || (_templateObject4$1 = math._taggedTemplateLiteral(["\n\t\tmat3 ", "(float angle) {\n\t\t\tfloat s = sin(angle);\n\t\t\tfloat c = cos(angle);\n\t\t\n\t\t\treturn mat3(\n\t\t\t\tc, s, 0.0,\n\t\t\t\t-s, c, 0.0,\n\t\t\t\t0.0, 0.0, 1.0\n\t\t\t);\n\t\t}\n\t"])), name);
});

var _templateObject$2, _templateObject2$1, _templateObject3$1, _templateObject4;

/**
 * Generates a Shader Unit of type `mat4` representing a rotation around a specified
 * axis, by a specified amount/angle. This unit can then be multiplied with a
 * `vec3` unit in order to apply the rotation to that vector.
 *
 * @param axis Axis to rotate around.
 * @param angle The angle (amount) to rotate.
 * @returns A Shader Unit of type `mat4` representing the rotation matrix.
 */
var Rotation3D = function Rotation3D(axis, angle) {
  return math.Mat4(math.$(_templateObject$2 || (_templateObject$2 = math._taggedTemplateLiteral(["", "(", ", ", ")"])), rotation3d, axis, angle));
};
var Rotation3DX = function Rotation3DX(angle) {
  return math.Mat3(math.$(_templateObject2$1 || (_templateObject2$1 = math._taggedTemplateLiteral(["", "(", ")"])), rotation3dX, angle));
};
var Rotation3DY = function Rotation3DY(angle) {
  return math.Mat3(math.$(_templateObject3$1 || (_templateObject3$1 = math._taggedTemplateLiteral(["", "(", ")"])), rotation3dY, angle));
};
var Rotation3DZ = function Rotation3DZ(angle) {
  return math.Mat3(math.$(_templateObject4 || (_templateObject4 = math._taggedTemplateLiteral(["", "(", ")"])), rotation3dZ, angle));
};

/**
 * Rotate a vector around the specified axis.
 *
 * @param position Vector to rotate.
 * @param axis The axis to rotate around.
 * @param angle The angle (amount) to rotate around the axis.
 * @returns A `vec3` Shader Unit containing the rotated vector.
 */
var Rotate3D = function Rotate3D(position, axis, angle) {
  return math.Mul(position, math.$mat3(Rotation3D(axis, angle)));
};
var RotateX = function RotateX(position, angle) {
  return math.Mul(position, Rotation3DX(angle));
};
var RotateY = function RotateY(position, angle) {
  return math.Mul(position, Rotation3DY(angle));
};
var RotateZ = function RotateZ(position, angle) {
  return math.Mul(position, Rotation3DZ(angle));
};

var _templateObject$1, _templateObject2, _templateObject3;
var Texture2D = function Texture2D(sampler2D, xy) {
  var texture2D = math.Vec4(math.$(_templateObject$1 || (_templateObject$1 = math._taggedTemplateLiteral(["texture2D(", ", ", ")"])), sampler2D, xy), {
    name: "Texture2D"
  });
  return math._objectSpread2(math._objectSpread2({}, texture2D), {}, {
    /** The color value sampled from the texture. */
    color: math.Vec3(math.$(_templateObject2 || (_templateObject2 = math._taggedTemplateLiteral(["", ".rgb"])), texture2D), {
      name: "Texture2D Color"
    }),
    /** The alpha value sampled from the texture. */
    alpha: math.Float(math.$(_templateObject3 || (_templateObject3 = math._taggedTemplateLiteral(["", ".a"])), texture2D), {
      name: "Texture2D Alpha"
    })
  });
};

var _templateObject;
var SceneColor = function SceneColor(uv, texture) {
  return Texture2D(texture, uv);
};

/**
 * Sample a depth texture and return the raw depth value.
 *
 * @param uv Screen UV
 * @param depthTexture Depth texture to sample
 * @returns Float unit containing the depth as stored in the texture
 */
var RawDepth = function RawDepth(uv, depthTexture) {
  return math.Float(Texture2D(depthTexture, uv).x, {
    name: "Read Depth from Depth Texture (Raw)"
  });
};

/**
 * Sample a depth texture and return the depth value in eye space units.
 *
 * @param xy Screen position
 * @param depthTexture Depth texture to sample
 * @param cameraNear Camera near plane (defaults to CameraNear)
 * @param cameraFar Camera far plane (defaults to CameraFar)
 * @returns Float unit containing the depth in eye space units
 */
var PerspectiveDepth = function PerspectiveDepth(xy, depthTexture) {
  var cameraNear = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : CameraNear;
  var cameraFar = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : CameraFar;
  return math.Float(_function.pipe(xy, function (v) {
    return RawDepth(v, depthTexture);
  }, function (v) {
    return math.$(_templateObject || (_templateObject = math._taggedTemplateLiteral(["perspectiveDepthToViewZ(", ", ", ", ", ")"])), v, cameraNear, cameraFar);
  }), {
    name: "Read Depth from Depth Texture (Eye Space)"
  });
};

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = math._unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function () {};
      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var DEBUG = false;
var enableDebugging = function enableDebugging() {
  DEBUG = true;
};
var disableDebugging = function disableDebugging() {
  DEBUG = false;
};

/**
 * Given a root unit, iterate over the tree and invoke the given callback for each
 * item encountered. Items include units, expressions, snippets, and any constant
 * values.
 *
 * @param item The root of the tree to traverse.
 * @param callback The callback to execute for each item.
 */
var walkTree = function walkTree(item, program, callback) {
  var seen = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Set();
  /* Visit each item only once */
  if (seen.has(item)) return;
  seen.add(item);

  /* Dive into dependencies */
  for (var _i = 0, _getDependencies = getDependencies(item, program); _i < _getDependencies.length; _i++) {
    var dependency = _getDependencies[_i];
    walkTree(dependency, program, callback, seen);
  }

  /* Invoke callback */
  callback(item);
};

/**
 * Walks the tree and returns all items found where the given callback function
 * returns true.
 */
var collectFromTree = function collectFromTree(root, program, check) {
  var found = new Array();
  walkTree(root, program, function (item) {
    if (check !== undefined ? check(item) : true) {
      found.push(item);
    }
  });
  return found;
};

/**
 * Given a unit, expression o snippet, returns that item's dependencies.
 *
 * @param item
 * @returns
 */
var getDependencies = function getDependencies(item, program) {
  var dependencies = math.isUnit(item) ? getUnitDependencies(item, program) : math.isExpression(item) ? item.values : math.isSnippet(item) ? item.expression.values : [];
  return dependencies.flat(Infinity).filter(dependencyFilter);
};
var getUnitDependencies = function getUnitDependencies(_ref, program) {
  var _config$vertex, _config$vertex$header, _config$vertex2, _config$vertex2$body, _config$fragment, _config$fragment$head, _config$fragment2, _config$fragment2$bod;
  var config = _ref._unitConfig;
  var dependencies = new Array();
  if (!config.varying || program === "any" || program === "vertex") dependencies.push(config.value);
  if (program === "any" || program === "vertex") dependencies.push((_config$vertex = config.vertex) === null || _config$vertex === void 0 ? void 0 : (_config$vertex$header = _config$vertex.header) === null || _config$vertex$header === void 0 ? void 0 : _config$vertex$header.values, (_config$vertex2 = config.vertex) === null || _config$vertex2 === void 0 ? void 0 : (_config$vertex2$body = _config$vertex2.body) === null || _config$vertex2$body === void 0 ? void 0 : _config$vertex2$body.values);
  if (program === "any" || program === "fragment") dependencies.push((_config$fragment = config.fragment) === null || _config$fragment === void 0 ? void 0 : (_config$fragment$head = _config$fragment.header) === null || _config$fragment$head === void 0 ? void 0 : _config$fragment$head.values, (_config$fragment2 = config.fragment) === null || _config$fragment2 === void 0 ? void 0 : (_config$fragment2$bod = _config$fragment2.body) === null || _config$fragment2$bod === void 0 ? void 0 : _config$fragment2$bod.values);
  return dependencies.filter(dependencyFilter);
};
var dependencyFilter = function dependencyFilter(item) {
  return !!item;
};

var idGenerator = (function () {
  var initial = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return function () {
    return ++initial;
  };
});

var beginUnit = function beginUnit(unit) {
  return "/*** UNIT: ".concat(unit._unitConfig.name, " ***/");
};
var endUnit = function endUnit(unit) {
  return "\n";
};
var compileItem = function compileItem(item, program, state) {
  if (state.seen.has(item)) return;
  state.seen.add(item);

  /* If the item is something we know, delegate to the corresponding function */
  if (math.isUnit(item)) compileUnit(item, program, state);else if (math.isSnippet(item)) compileSnippet(item, program, state);
};
var compileSnippet = function compileSnippet(snippet, program, state) {
  /* Add snippet to header */
  state.header.push(snippet.expression);
};
var compileUnit = function compileUnit(unit, program, state) {
  var _unit$_unitConfig$pro, _state$header, _unit$_unitConfig$pro3, _unit$_unitConfig$pro4;
  /* As a sanity check, check if the unit is even allowed to be compiled into
  the requested program. */
  if (!math.isUnitInProgram(unit, program)) {
    throw new Error(program === "vertex" ? "Encountered a unit \"".concat(unit._unitConfig.name, "\" that is only allowed in the fragment shader, but was encountered when compiling the vertex shader. Please check your unit connections.") : "Encountered a unit \"".concat(unit._unitConfig.name, "\" that is only allowed in the vertex shader, but was encountered when compiling the fragment shader. Consider wrapping the value, or the derived value you're interested in, in a Unit that has a varying."));
  }

  /* HEADER */
  var header = new Array();

  /* Declare varying if this unit has varying mode */
  if (unit._unitConfig.varying) {
    header.push(math.statement(unit._unitConfig.varying === "flat" ? "flat" : undefined, "varying", unit._unitConfig.type, "v_".concat(unit._unitConfig.variableName)));
  }

  /* Declare uniform, if one is configured. */
  if (unit._unitConfig.uniform) {
    /* Declare uniforms in header */
    header.push(math.statement("uniform", unit._unitConfig.type, math.uniformName(unit)));
  }

  /* Add header if present */
  if ((_unit$_unitConfig$pro = unit._unitConfig[program]) !== null && _unit$_unitConfig$pro !== void 0 && _unit$_unitConfig$pro.header) {
    var _unit$_unitConfig$pro2;
    header.push((_unit$_unitConfig$pro2 = unit._unitConfig[program]) === null || _unit$_unitConfig$pro2 === void 0 ? void 0 : _unit$_unitConfig$pro2.header);
  }
  if (header.length) (_state$header = state.header).push.apply(_state$header, [beginUnit(unit)].concat(header, [endUnit()]));

  /* BODY */

  var value = unit._unitConfig.varying && program === "fragment" ? "v_".concat(unit._unitConfig.variableName) : unit._unitConfig.uniform ? math.uniformName(unit) : math.glslRepresentation(unit._unitConfig.value, unit._unitConfig.type);
  state.body.push(beginUnit(unit));

  /*
  Declare the unit's global variable, and assign the specified value to it.
  */
  if (!unit._unitConfig.uniform) {
    state.body.push(math.statement(unit._unitConfig.type, unit._unitConfig.variableName, "=", value));
  }

  /*
  If a body chunk is given, we'll create a scoped block with a local variable called
  "value" that the chunk can modify before it is assigned back to the unit's global.
  */
  if ((_unit$_unitConfig$pro3 = unit._unitConfig[program]) !== null && _unit$_unitConfig$pro3 !== void 0 && _unit$_unitConfig$pro3.body) state.body.push(math.block( /* Declare local value variable */
  !unit._unitConfig.uniform && math.statement(unit._unitConfig.type, "value", "=", unit._unitConfig.variableName), /* Include body chunk */(_unit$_unitConfig$pro4 = unit._unitConfig[program]) === null || _unit$_unitConfig$pro4 === void 0 ? void 0 : _unit$_unitConfig$pro4.body, /* Re-assign local value variable to global variable */
  !unit._unitConfig.uniform && math.assignment(unit._unitConfig.variableName, "value")));

  /*
  If we're in varying mode and vertex, write value to the varying, too.
  */
  if (!unit._unitConfig.uniform && unit._unitConfig.varying && program === "vertex") {
    state.body.push(math.assignment("v_".concat(unit._unitConfig.variableName), unit._unitConfig.variableName));
  }
  state.body.push(endUnit());
};
var prepareItem = function prepareItem(item, nextId) {
  /* Prepare this unit */
  if (math.isUnit(item)) {
    /* Assign a variable name */
    item._unitConfig.variableName = math.identifier(math.sluggify(item._unitConfig.name), nextId());
    return;
  }

  /* Is it a snippet? */
  if (math.isSnippet(item)) {
    math.renameSnippet(item, "snippet_".concat(nextId()));
    return;
  }
};
var compileProgram = function compileProgram(unit, program, state) {
  walkTree(unit, program, function (item) {
    return compileItem(item, program, state);
  });
  return math.concatenate("/*** PROGRAM: ".concat(program.toUpperCase(), " ***/\n"), "precision highp float;\n", state.header, "void main()", math.block(state.body));
};
var compileShader = function compileShader(root) {
  /* STEP 1: prepare all units and their dependencies! */
  var nextId = idGenerator();
  walkTree(root, "any", function (item) {
    return prepareItem(item, nextId);
  });

  /*
  STEP 2: compile the fragment shader. We're going to compile it first because
  we need to identify units with varyings, because we will _always_ want to
  include them in the vertex shader.
  */
  var fragmentState = CompilerState();
  var fragmentShader = compileProgram(root, "fragment", fragmentState);

  /*
  STEP 3: compile the vertex shader. But first, we'll manually squeeze in all
  units with varyings.
  */
  var vertexState = CompilerState();

  /* Explicitly add all units with varyings. */
  fragmentState.seen.forEach(function (item) {
    if (math.isUnit(item) && item._unitConfig.varying) {
      walkTree(item, "vertex", function (item) {
        return compileItem(item, "vertex", vertexState);
      });
    }
  });

  /* Compile! */
  var vertexShader = compileProgram(root, "vertex", vertexState);

  /*
  STEP 4: Collect uniforms.
  */
  var unitsWithUniforms = collectFromTree(root, "any", function (item) {
    return math.isUnit(item) && !!item._unitConfig.uniform;
  });
  var uniforms = unitsWithUniforms.reduce(function (acc, unit) {
    return math._objectSpread2(math._objectSpread2({}, acc), {}, math._defineProperty({}, math.uniformName(unit), unit._unitConfig.uniform));
  }, {});

  /*
  STEP 5: Collect update callbacks.
  */
  var unitsWithUpdates = collectFromTree(root, "any", function (item) {
    return math.isUnit(item) && !!item._unitConfig.update;
  });

  /*
  STEP 6: Build per-frame update function.
  */
  var update = function update(dt, camera, scene, gl) {
    var now = performance.now();
    var _iterator = _createForOfIteratorHelper(unitsWithUpdates),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var unit = _step.value;
        var state = unit._unitState;

        /* Only invoke the update callback once per frame. */
        if (state.lastUpdateAt === undefined || state.lastUpdateAt < now) {
          unit._unitConfig.update(dt, camera, scene, gl);
          state.lastUpdateAt = now;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  };

  /* Build a dispose function */
  var allUnits = collectFromTree(root, "any", math.isUnit);
  var dispose = function dispose() {
    return allUnits.forEach(function (u) {
      var _u$_unitConfig$dispos, _u$_unitConfig;
      return (_u$_unitConfig$dispos = (_u$_unitConfig = u._unitConfig).dispose) === null || _u$_unitConfig$dispos === void 0 ? void 0 : _u$_unitConfig$dispos.call(_u$_unitConfig);
    });
  };

  /*
  DONE! Let's return everything and go on a lengthy vacation somewhere nice.
  */
  var shader = {
    vertexShader: vertexShader,
    fragmentShader: fragmentShader,
    uniforms: uniforms
  };
  var meta = {
    update: update,
    dispose: dispose
  };
  if (DEBUG) {
    console.debug("[SC] Compiled shader");
  }
  return [shader, meta];
};
var CompilerState = function CompilerState() {
  return {
    header: new Array(),
    body: new Array(),
    nextid: idGenerator(),
    seen: new Set()
  };
};

exports.$ = math.$;
exports.$float = math.$float;
exports.$inverseLerp = math.$inverseLerp;
exports.$lerp = math.$lerp;
exports.$mat2 = math.$mat2;
exports.$mat3 = math.$mat3;
exports.$mat4 = math.$mat4;
exports.$remap = math.$remap;
exports.$swizzle = math.$swizzle;
exports.$vec2 = math.$vec2;
exports.$vec3 = math.$vec3;
exports.$vec4 = math.$vec4;
exports.Abs = math.Abs;
exports.Acos = math.Acos;
exports.Add = math.Add;
exports.Asin = math.Asin;
exports.Bool = math.Bool;
exports.Ceil = math.Ceil;
exports.Clamp = math.Clamp;
exports.Clamp01 = math.Clamp01;
exports.Cos = math.Cos;
exports.Degrees = math.Degrees;
exports.Div = math.Div;
exports.Divide = math.Divide;
exports.Exp = math.Exp;
exports.Exp2 = math.Exp2;
exports.Float = math.Float;
exports.Floor = math.Floor;
exports.Fract = math.Fract;
exports.Int = math.Int;
exports.InverseLerp = math.InverseLerp;
exports.InverseSqrt = math.InverseSqrt;
exports.Lerp = math.Lerp;
exports.Log = math.Log;
exports.Log2 = math.Log2;
exports.Master = math.Master;
exports.Mat2 = math.Mat2;
exports.Mat3 = math.Mat3;
exports.Mat4 = math.Mat4;
exports.Max = math.Max;
exports.Min = math.Min;
exports.Mix = math.Mix;
exports.Modulo = math.Modulo;
exports.Mul = math.Mul;
exports.Multiply = math.Multiply;
exports.Negate = math.Negate;
exports.NormalizePlusMinusOne = math.NormalizePlusMinusOne;
exports.OneMinus = math.OneMinus;
exports.Operator = math.Operator;
exports.Pow = math.Pow;
exports.Radians = math.Radians;
exports.Remap = math.Remap;
exports.Round = math.Round;
exports.Saturate = math.Saturate;
exports.ScaleAndOffset = math.ScaleAndOffset;
exports.Sign = math.Sign;
exports.Sin = math.Sin;
exports.SingleArgumentFunction = math.SingleArgumentFunction;
exports.Smoothstep = math.Smoothstep;
exports.Snippet = math.Snippet;
exports.Sqrt = math.Sqrt;
exports.Step = math.Step;
exports.Sub = math.Sub;
exports.Subtract = math.Subtract;
exports.Tan = math.Tan;
exports.Trunc = math.Trunc;
exports.Unit = math.Unit;
exports.Vec2 = math.Vec2;
exports.Vec3 = math.Vec3;
exports.Vec4 = math.Vec4;
exports.glsl = math.glsl;
exports.glslType = math.glslType;
exports.injectAPI = math.injectAPI;
exports.isExpression = math.isExpression;
exports.isSnippet = math.isSnippet;
exports.isUnit = math.isUnit;
exports.isUnitInProgram = math.isUnitInProgram;
exports.renameSnippet = math.renameSnippet;
exports.type = math.type;
exports.uniformName = math.uniformName;
exports.unit = math.unit;
exports.varying = math.varying;
exports.$localToViewSpace = $localToViewSpace;
exports.$localToWorldSpace = $localToWorldSpace;
exports.$orthogonal = $orthogonal;
exports.Attribute = Attribute;
exports.Bitangent = Bitangent;
exports.CameraFar = CameraFar;
exports.CameraNear = CameraNear;
exports.CameraPosition = CameraPosition;
exports.Cross = Cross;
exports.CustomShaderMaterialMaster = CustomShaderMaterialMaster;
exports.Distance = Distance;
exports.Dot = Dot;
exports.FragmentCoordinate = FragmentCoordinate;
exports.Fresnel = Fresnel;
exports.GlobalTime = GlobalTime;
exports.Gradient = Gradient;
exports.GreaterOrEqual = GreaterOrEqual;
exports.If = If;
exports.InstanceID = InstanceID;
exports.InstanceMatrix = InstanceMatrix;
exports.IsFrontFacing = IsFrontFacing;
exports.Length = Length;
exports.LocalToViewSpace = LocalToViewSpace;
exports.LocalToWorldSpace = LocalToWorldSpace;
exports.Luminance = Luminance;
exports.ModelMatrix = ModelMatrix;
exports.ModelViewMatrix = ModelViewMatrix;
exports.NormalMatrix = NormalMatrix;
exports.Normalize = Normalize;
exports.PerspectiveDepth = PerspectiveDepth;
exports.ProjectionMatrix = ProjectionMatrix;
exports.RawDepth = RawDepth;
exports.Reflect = Reflect;
exports.Refract = Refract;
exports.Resolution = Resolution;
exports.Rotate3D = Rotate3D;
exports.RotateX = RotateX;
exports.RotateY = RotateY;
exports.RotateZ = RotateZ;
exports.Rotation3D = Rotation3D;
exports.Rotation3DX = Rotation3DX;
exports.Rotation3DY = Rotation3DY;
exports.Rotation3DZ = Rotation3DZ;
exports.SceneColor = SceneColor;
exports.ScreenUV = ScreenUV;
exports.ShaderMaterialMaster = ShaderMaterialMaster;
exports.Tangent = Tangent;
exports.Texture2D = Texture2D;
exports.Time = Time;
exports.UV = UV;
exports.UniformUnit = UniformUnit;
exports.UsingInstancing = UsingInstancing;
exports.VertexID = VertexID;
exports.VertexNormal = VertexNormal;
exports.VertexPosition = VertexPosition;
exports.ViewDirection = ViewDirection;
exports.ViewMatrix = ViewMatrix;
exports.collectFromTree = collectFromTree;
exports.compileShader = compileShader;
exports.disableDebugging = disableDebugging;
exports.enableDebugging = enableDebugging;
exports.getDependencies = getDependencies;
exports.walkTree = walkTree;
