import { Camera, Color, Matrix3, Matrix4, Scene, Texture, Vector2, Vector3, Vector4, WebGLRenderer } from "three";
import { Expression } from "./expressions";
export declare type Program = "vertex" | "fragment";
/**
 * Currently supported GLSLTypes. Probably incomplete!
 */
export declare type GLSLType = "bool" | "int" | "float" | "vec2" | "vec3" | "vec4" | "mat2" | "mat3" | "mat4" | "sampler2D";
export declare type JSTypes = {
    bool: boolean;
    float: number;
    int: number;
    vec2: Vector2;
    vec3: Vector3 | Color;
    vec4: Vector4;
    mat2: [number, number, number, number];
    mat3: Matrix3;
    mat4: Matrix4;
    sampler2D: Texture;
};
export declare type Input<T extends GLSLType = any> = Expression | JSTypes[T] | Unit<T>;
export declare type UpdateCallback = (dt: number, camera: Camera, scene: Scene, gl: WebGLRenderer) => void;
export declare type UnitConfig<T extends GLSLType> = {
    /**
     * Human-readable name of this unit.
     */
    name: string;
    /**
     * Machine-readable name of the global variable for this unit.
     * Will be recreated by the compiler, so no need to set this yourself.
     */
    variableName: string;
    /**
     * The GLSL type of this unit.
     */
    type: T;
    /**
     * The value of this unit. Can be a reference to another unit,
     * a JavaScript type that matches this unit's GLSL type, or
     * an Expression.
     */
    value: Input<T> | undefined;
    /**
     * If this is set to "vertex" or "fragment", the compiler will
     * only ever render this node in the specified program. If you
     * have units referencing gl_* variables that only exist in one
     * of the programs, use this to make sure they never appear
     * in the other program (which would lead to compilation failure.)
     */
    only?: Program;
    /**
     * When set to true, this variable will automatically declare a varying,
     * calculate/source its value in the vertex program only, and pass the
     * result to the fragment program through that varying.
     *
     * Alternatively, you can set this to "flat", which will declare a
     * flat varying (whose values will not be interpolated between vertices.)
     *
     * Default: false.
     */
    varying: boolean | "flat";
    /**
     * An optional uniform object. It will automatically be
     * declared in the program headers, and also made available in the
     * object returned by `compilerShader`.
     */
    uniform?: {
        value: JSTypes[T];
    };
    uniformName?: string;
    /**
     * A callback that will be executed once per frame.
     */
    update?: UpdateCallback;
    /**
     * A callback that will be executed when the shader is being disposed.
     */
    dispose?: () => void;
    vertex?: {
        header?: Expression;
        body?: Expression;
    };
    fragment?: {
        header?: Expression;
        body?: Expression;
    };
};
export declare type UnitState<T extends GLSLType> = {
    lastUpdateAt: number | undefined;
};
export declare type UnitAPI<T extends GLSLType> = T extends "vec2" ? {
    readonly x: Unit<"float">;
    readonly y: Unit<"float">;
} : T extends "vec3" ? {
    readonly x: Unit<"float">;
    readonly y: Unit<"float">;
    readonly z: Unit<"float">;
} : T extends "vec4" ? {
    readonly x: Unit<"float">;
    readonly y: Unit<"float">;
    readonly z: Unit<"float">;
    readonly w: Unit<"float">;
} : {};
export interface IUnit<T extends GLSLType = GLSLType> {
    _: "Unit";
    _unitConfig: UnitConfig<T>;
    _unitState: UnitState<T>;
}
export declare type Unit<T extends GLSLType = GLSLType> = IUnit<T> & UnitAPI<T>;
export declare const Unit: <T extends GLSLType>(type: T, value: Input<T> | undefined, _config?: Partial<UnitConfig<T>> | undefined) => Unit<T>;
export declare function isUnit(value: any): value is Unit;
export declare const isUnitInProgram: (unit: Unit, program: Program) => boolean;
export declare const uniformName: (unit: Unit) => string;
export declare type APIFactory<U extends IUnit, A> = (unit: U) => A;
/**
 * Given a unit and an API factory function, pass the unit to the factory
 * function and inject its return value into the unit (as to not break
 * object references.)
 */
export declare const injectAPI: <U extends IUnit<GLSLType>, A>(unit: U, factory: APIFactory<U, A>) => U & A;
