import { GLSLType, Input, Unit } from "../units";
/**
 * @internal
 */
export declare const Operator: (name: string, operator: "+" | "-" | "*" | "/") => <A extends GLSLType, B extends GLSLType>(a: Input<A>, b: Input<B>) => Unit<A>;
/**
 * @internal
 */
export declare const SingleArgumentFunction: <TA extends GLSLType = "float" | "vec2" | "vec3" | "vec4">(name: string, functionName: string) => <A extends TA>(a: Input<A>) => Unit<A>;
/**
 * A Shader Unit that adds two values and returns the result.
 */
export declare const Add: <A extends GLSLType, B extends GLSLType>(a: Input<A>, b: Input<B>) => Unit<A>;
/**
 * A Shader Unit that subtracts two values and returns the result.
 */
export declare const Sub: <A extends GLSLType, B extends GLSLType>(a: Input<A>, b: Input<B>) => Unit<A>;
export declare const Subtract: <A extends GLSLType, B extends GLSLType>(a: Input<A>, b: Input<B>) => Unit<A>;
/**
 * A Shader Unit that multiplies two values and returns the result.
 */
export declare const Mul: <A extends GLSLType, B extends GLSLType>(a: Input<A>, b: Input<B>) => Unit<A>;
export declare const Multiply: <A extends GLSLType, B extends GLSLType>(a: Input<A>, b: Input<B>) => Unit<A>;
/**
 * A Shader Unit that divides two values and returns the result.
 */
export declare const Div: <A extends GLSLType, B extends GLSLType>(a: Input<A>, b: Input<B>) => Unit<A>;
export declare const Divide: <A extends GLSLType, B extends GLSLType>(a: Input<A>, b: Input<B>) => Unit<A>;
/**
 * Calculates the sine value of the input value.
 */
export declare const Sin: <A extends "float" | "vec2" | "vec3" | "vec4">(a: Input<A>) => Unit<A>;
/**
 * Calculates the cosine value of the input value.
 */
export declare const Cos: <A extends "float" | "vec2" | "vec3" | "vec4">(a: Input<A>) => Unit<A>;
export declare const Tan: <A extends "float" | "vec2" | "vec3" | "vec4">(a: Input<A>) => Unit<A>;
export declare const Asin: <A extends "float" | "vec2" | "vec3" | "vec4">(a: Input<A>) => Unit<A>;
export declare const Acos: <A extends "float" | "vec2" | "vec3" | "vec4">(a: Input<A>) => Unit<A>;
export declare const Pow: <T extends "float" | "vec2" | "vec3" | "vec4">(a: Input<T>, e: Input<T>) => Unit<T>;
export declare const Exp: <A extends "float" | "vec2" | "vec3" | "vec4">(a: Input<A>) => Unit<A>;
export declare const Exp2: <A extends "float" | "vec2" | "vec3" | "vec4">(a: Input<A>) => Unit<A>;
export declare const Log: <A extends "float" | "vec2" | "vec3" | "vec4">(a: Input<A>) => Unit<A>;
export declare const Log2: <A extends "float" | "vec2" | "vec3" | "vec4">(a: Input<A>) => Unit<A>;
export declare const Sqrt: <A extends "float" | "vec2" | "vec3" | "vec4">(a: Input<A>) => Unit<A>;
export declare const InverseSqrt: <A extends "float" | "vec2" | "vec3" | "vec4">(a: Input<A>) => Unit<A>;
/**
 * A Shader Unit that finds the nearest integer less than or equal to the input value.
 * It is equivalent to the GLSL expression `trunc(a)`.
 *
 * @param a The input value.
 * @returns The truncated value of `a`.
 */
export declare const Trunc: <A extends "float" | "vec2" | "vec3" | "vec4">(a: Input<A>) => Unit<A>;
/**
 * A Shader Unit that finds the nearest integer to the input value.
 * It performs the GLSL expression `round(a)`.
 *
 * @param a The input value.
 * @returns The rounded value of `a`.
 */
export declare const Round: <A extends "float" | "vec2" | "vec3" | "vec4">(a: Input<A>) => Unit<A>;
export declare const Fract: <A extends "float" | "vec2" | "vec3" | "vec4">(a: Input<A>) => Unit<A>;
export declare const Floor: <A extends "float" | "vec2" | "vec3" | "vec4">(a: Input<A>) => Unit<A>;
export declare const Ceil: <A extends "float" | "vec2" | "vec3" | "vec4">(a: Input<A>) => Unit<A>;
export declare const Abs: <A extends "float" | "vec2" | "vec3" | "vec4">(a: Input<A>) => Unit<A>;
export declare const Sign: <A extends "float" | "vec2" | "vec3" | "vec4">(a: Input<A>) => Unit<A>;
/**
 * Converts the given value from degrees to radians.
 */
export declare const Radians: <A extends "float" | "vec2" | "vec3" | "vec4">(a: Input<A>) => Unit<A>;
/**
 * Converts the given value from radians to degrees.
 */
export declare const Degrees: <A extends "float" | "vec2" | "vec3" | "vec4">(a: Input<A>) => Unit<A>;
export declare const Modulo: <A extends "float" | "vec2" | "vec3" | "vec4", B extends "float" | A>(a: Input<A>, b: Input<B>) => Unit<A>;
export declare const Clamp: <T extends GLSLType>(x: Input<T>, min: Input<T>, max: Input<T>) => Unit<T>;
export declare const Clamp01: (x: Input<"float">) => import("../units").IUnit<"float">;
export declare const Saturate: (x: Input<"float">) => import("../units").IUnit<"float">;
export declare const OneMinus: (v: Input<"float">) => import("../units").IUnit<"float">;
/**
 * Negates the value (equivalent to multiplying it with -1.)
 *
 * @param v Value to negate.
 * @returns A shader unit holding the negated value.
 */
export declare const Negate: <T extends GLSLType>(v: Input<T>) => Unit<T>;
/**
 * Lerpy fun!
 *
 * @group Math
 * @param a
 * @param b
 * @param ratio
 * @returns
 */
export declare const $lerp: <T extends GLSLType>(a: Input<T>, b: Input<T>, ratio: Input<"float">) => import("../expressions").Expression;
/**
 * Performs linear interpolation between two values, and returns the result.
 *
 * Wraps the GLSL `mix` function.
 *
 * @param a The starting value of the interpolation.
 * @param b The ending value of the interpolation.
 * @param ratio The interpolation ratio.
 * @returns The interpolated value.
 */
export declare const Lerp: <T extends GLSLType>(a: Input<T>, b: Input<T>, ratio: Input<"float">) => Unit<T>;
export declare const $inverseLerp: <T extends GLSLType>(a: Input<T>, b: Input<T>, c: Input<T>) => import("../expressions").Expression;
/**
 * Performs inverse linear interpolation between two values, and returns the result.
 * Given three values `a`, `b`, and `c`, the result is the ratio of `c` between `a` and `b`.
 * Also see {@link Lerp}.
 *
 * @param a The starting value of the interpolation.
 * @param b The ending value of the interpolation.
 * @param c The value to find the interpolation ratio of.
 * @returns The interpolation ratio of `c` between `a` and `b`.
 */
export declare const InverseLerp: <T extends GLSLType>(a: Input<T>, b: Input<T>, c: Input<T>) => Unit<T>;
export declare const Mix: <T extends GLSLType>(a: Input<T>, b: Input<T>, ratio: Input<"float">) => Unit<T>;
/**
 * Given an `edge` value and an input value `v`, returns 0 if the value is less than the
 * edge, and 1 if the value is greater than or equal to the edge.
 *
 * Wraps the GLSL `step` function.
 *
 * @example
 * Moooooooo
 *
 * ```jsx
 * Step(0.5, 0.25, f)
 * ```
 *
 * @param edge The edge value.
 * @param v The value to test.
 * @returns The result of the step function.
 */
export declare const Step: (edge: Input<"float">, v: Input<"float">) => import("../units").IUnit<"float">;
/**
 * Performs a Hermite interpolation between two values, and returns the result.
 *
 * Wraps the GLSL `smoothstep` function.
 *
 * @param min The lower edge of the Hermite einterpolation.
 * @param max The upper edge of the Hermite interpolation.
 * @param v The source value for the interpolation.
 * @returns The result of the Hermite interpolation.
 */
export declare const Smoothstep: (min: Input<"float">, max: Input<"float">, v: Input<"float">) => import("../units").IUnit<"float">;
export declare const $remap: <T extends "float" | "vec2" | "vec3" | "vec4">(value: Input<T>, inMin: Input<T>, inMax: Input<T>, outMin: Input<T>, outMax: Input<T>) => import("../expressions").Expression;
export declare const Remap: <T extends "float" | "vec2" | "vec3" | "vec4">(value: Input<T>, inMin: Input<T>, inMax: Input<T>, outMin: Input<T>, outMax: Input<T>) => Unit<T>;
export declare const NormalizePlusMinusOne: (f: Input<"float">) => import("../units").IUnit<"float">;
export declare const Min: <T extends "float" | "vec2" | "vec3" | "vec4">(a: Input<T>, b: Input<T>) => Unit<T>;
export declare const Max: <T extends "float" | "vec2" | "vec3" | "vec4">(a: Input<T>, b: Input<T>) => Unit<T>;
/**
 * Applies scaling (multiplication) and offset (addition) to a given value.
 *
 * @param v The value to scale and offset.
 * @param scale The scale to apply. (Default: 1)
 * @param offset The offset to apply. (Default: 0)
 * @returns A unit holding the scaled and offset value.
 */
export declare const ScaleAndOffset: <T extends GLSLType>(v: Input<T>, scale?: Input, offset?: Input) => Unit<T>;
