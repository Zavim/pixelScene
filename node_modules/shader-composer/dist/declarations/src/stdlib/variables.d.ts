import { Vector2 } from "three";
import { GLSLType, JSTypes, Unit, UnitConfig } from "../units";
/**
 * Returns the current fragment's on-screen coordinate.
 */
export declare const FragmentCoordinate: Unit<"vec2">;
/**
 * In instanced rendering, will return the instance ID.
 * Wraps the `gl_InstanceID` GLSL built-in.
 */
export declare const InstanceID: import("../units").IUnit<"int">;
/**
 * Returns the verte ID.
 * Wraps the `gl_VertexID` GLSL built-in.
 *
 * Note: available in vertex shader only!
 */
export declare const VertexID: import("../units").IUnit<"int">;
export declare const CameraPosition: Unit<"vec3">;
export declare const ViewMatrix: import("../units").IUnit<"mat4">;
export declare const ModelMatrix: import("../units").IUnit<"mat4">;
export declare const ModelViewMatrix: import("../units").IUnit<"mat4">;
export declare const NormalMatrix: import("../units").IUnit<"mat4">;
export declare const ProjectionMatrix: import("../units").IUnit<"mat4">;
/**
 * Returns true if instanced rendering is enabled, false if it is not.
 */
export declare const UsingInstancing: import("../units").IUnit<"bool">;
/**
 * Returns the instance matrix. Please note that this is only available when
 * instanced rendering is enabled.
 */
export declare const InstanceMatrix: import("../units").IUnit<"mat4">;
export declare const UV: Unit<"vec2">;
export declare const VertexPosition: import("../units").IUnit<"vec3"> & {
    readonly x: import("../units").IUnit<"float">;
    readonly y: import("../units").IUnit<"float">;
    readonly z: import("../units").IUnit<"float">;
} & {
    readonly world: Unit<"vec3">;
    readonly view: Unit<"vec3">;
};
export declare const VertexNormal: import("../units").IUnit<"vec3"> & {
    readonly x: import("../units").IUnit<"float">;
    readonly y: import("../units").IUnit<"float">;
    readonly z: import("../units").IUnit<"float">;
} & {
    readonly world: Unit<"vec3">;
    readonly view: Unit<"vec3">;
};
export declare const ViewDirection: Unit<"vec3">;
export declare const IsFrontFacing: import("../units").IUnit<"bool">;
export declare const Attribute: <T extends GLSLType>(type: T, name: string) => Unit<T>;
export declare type UniformUnit<T extends GLSLType, J extends JSTypes[T] = JSTypes[T]> = Unit<T> & {
    value: J;
};
export declare const UniformUnit: <T extends GLSLType, J extends JSTypes[T]>(type: T, initialValue: J, extras?: Partial<UnitConfig<T>> | undefined) => UniformUnit<T, J>;
/**
 * Provides a uniform unit holding a representation of time. The time value
 * stored is not an absolute time, so multiple instances of this unit will not
 * be synchronized. If you require synchronization, please either reuse the
 * same instance of this unit, or use `GlobalTime` instead.
 *
 * @param initial The initial time value to start with. (Default: 0)
 */
export declare const Time: (initial?: number) => UniformUnit<"float", number>;
/**
 * A global time uniform unit that can be safely used across multiple shaders,
 * wherever synchronization is required,
 * and as a default value for `time` inputs of other unit implementations, to prevent
 * shaders from being spammed by multiple uniforms all holding different
 * representations of time.
 */
export declare const GlobalTime: UniformUnit<"float", number>;
export declare const Resolution: UniformUnit<"vec2", Vector2>;
export declare const CameraNear: UniformUnit<"float", number>;
export declare const CameraFar: UniformUnit<"float", number>;
export declare const ScreenUV: Unit<"vec2">;
