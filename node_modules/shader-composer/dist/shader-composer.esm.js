import { $, _ as _taggedTemplateLiteral, V as Vec3, b as Vec2, I as Int, c as Mat4, B as Bool, U as Unit, d as _objectSpread2, i as injectAPI, t as type, F as Float, A as Add, e as Abs, P as Pow, a as Mul, f as Saturate, L as Lerp, g as Smoothstep, h as Master, j as Snippet, k as glsl, l as Mat3, m as $mat3, n as Vec4, o as _unsupportedIterableToArray, p as isUnit, q as isExpression, r as isSnippet, s as _defineProperty, u as uniformName, v as isUnitInProgram, w as statement, x as glslRepresentation, y as block, z as assignment, C as identifier, E as sluggify, G as renameSnippet, H as concatenate } from './math-2ba7a8b8.esm.js';
export { $, at as $float, ak as $inverseLerp, aj as $lerp, ax as $mat2, m as $mat3, ay as $mat4, an as $remap, az as $swizzle, au as $vec2, av as $vec3, aw as $vec4, e as Abs, Z as Acos, A as Add, Y as Asin, B as Bool, aa as Ceil, af as Clamp, ag as Clamp01, W as Cos, ad as Degrees, D as Div, R as Divide, a0 as Exp, a1 as Exp2, F as Float, a9 as Floor, a8 as Fract, I as Int, al as InverseLerp, a5 as InverseSqrt, L as Lerp, a2 as Log, a3 as Log2, h as Master, aC as Mat2, l as Mat3, c as Mat4, ar as Max, aq as Min, M as Mix, ae as Modulo, a as Mul, Q as Multiply, ai as Negate, ap as NormalizePlusMinusOne, ah as OneMinus, O as Operator, P as Pow, ac as Radians, ao as Remap, a7 as Round, f as Saturate, as as ScaleAndOffset, ab as Sign, T as Sin, K as SingleArgumentFunction, g as Smoothstep, j as Snippet, a4 as Sqrt, am as Step, S as Sub, N as Subtract, X as Tan, a6 as Trunc, U as Unit, b as Vec2, V as Vec3, n as Vec4, k as glsl, J as glslType, i as injectAPI, q as isExpression, r as isSnippet, p as isUnit, v as isUnitInProgram, G as renameSnippet, t as type, u as uniformName, aA as unit, aB as varying } from './math-2ba7a8b8.esm.js';
import { pipe } from 'fp-ts/function';
import { Vector2, PerspectiveCamera, Color } from 'three';

var _templateObject$9, _templateObject2$7;

// "Note that modelViewMatrix is not set when rendering an instanced model"
// https://threejs.org/docs/#api/en/renderers/webgl/WebGLProgram
var $localToViewSpace = function $localToViewSpace(v) {
  return $(_templateObject$9 || (_templateObject$9 = _taggedTemplateLiteral(["\n  vec3(\n    ", " *\n    ", " *\n    #ifdef USE_INSTANCING\n    instanceMatrix *\n    #endif\n    vec4(", ", 1.0)\n  )\n"])), ViewMatrix, ModelMatrix, v);
};
var $localToWorldSpace = function $localToWorldSpace(v) {
  return $(_templateObject2$7 || (_templateObject2$7 = _taggedTemplateLiteral(["\n  vec3(\n    ", " *\n    #ifdef USE_INSTANCING\n    instanceMatrix *\n    #endif\n    vec4(", ", 1.0)\n  )\n"])), ModelMatrix, v);
};

/**
 * Converts the given position vector (which is assumed to be in local space)
 * to view space.
 */
var LocalToViewSpace = function LocalToViewSpace(position) {
  return Vec3($localToViewSpace(position));
};

/**
 * Converts the given position vector (which is assumed to be in local space)
 * to world space.
 */
var LocalToWorldSpace = function LocalToWorldSpace(position) {
  return Vec3($localToWorldSpace(position));
};

var _templateObject$8, _templateObject2$6, _templateObject3$5, _templateObject4$4, _templateObject5$2, _templateObject6$2, _templateObject7$2, _templateObject8$2, _templateObject9$1, _templateObject10$1, _templateObject11$1, _templateObject12$1, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18, _templateObject19;

/**
 * Returns the current fragment's on-screen coordinate.
 */
var FragmentCoordinate = Vec2($(_templateObject$8 || (_templateObject$8 = _taggedTemplateLiteral(["gl_FragCoord.xy"]))), {
  name: "Fragment Coordinate",
  only: "fragment"
});

/**
 * In instanced rendering, will return the instance ID.
 * Wraps the `gl_InstanceID` GLSL built-in.
 */
var InstanceID = Int($(_templateObject2$6 || (_templateObject2$6 = _taggedTemplateLiteral(["gl_InstanceID"]))), {
  name: "Instance ID",
  varying: "flat"
});

/**
 * Returns the verte ID.
 * Wraps the `gl_VertexID` GLSL built-in.
 *
 * Note: available in vertex shader only!
 */
var VertexID = Int($(_templateObject3$5 || (_templateObject3$5 = _taggedTemplateLiteral(["gl_VertexID"]))), {
  name: "Vertex ID",
  only: "vertex"
});
var CameraPosition = Vec3($(_templateObject4$4 || (_templateObject4$4 = _taggedTemplateLiteral(["cameraPosition"]))), {
  name: "Camera Position"
});
var ViewMatrix = Mat4($(_templateObject5$2 || (_templateObject5$2 = _taggedTemplateLiteral(["viewMatrix"]))), {
  name: "View Matrix"
});
var ModelMatrix = Mat4($(_templateObject6$2 || (_templateObject6$2 = _taggedTemplateLiteral(["modelMatrix"]))), {
  name: "Model Matrix"
});
var ModelViewMatrix = Mat4($(_templateObject7$2 || (_templateObject7$2 = _taggedTemplateLiteral(["modelViewMatrix"]))), {
  name: "ModelView Matrix"
});
var NormalMatrix = Mat4($(_templateObject8$2 || (_templateObject8$2 = _taggedTemplateLiteral(["normalMatrix"]))), {
  name: "Normal Matrix"
});
var ProjectionMatrix = Mat4($(_templateObject9$1 || (_templateObject9$1 = _taggedTemplateLiteral(["projectionMatrix"]))), {
  name: "Projection Matrix"
});

/**
 * Returns true if instanced rendering is enabled, false if it is not.
 */
var UsingInstancing = Bool($(_templateObject10$1 || (_templateObject10$1 = _taggedTemplateLiteral(["\n  #ifdef USE_INSTANCING\n    true\n  #else\n    false\n  #endif\n"]))));

/**
 * Returns the instance matrix. Please note that this is only available when
 * instanced rendering is enabled.
 */
var InstanceMatrix = Mat4($(_templateObject11$1 || (_templateObject11$1 = _taggedTemplateLiteral(["instanceMatrix"]))), {
  name: "Instance Matrix",
  only: "vertex"
});
var UV = Vec2($(_templateObject12$1 || (_templateObject12$1 = _taggedTemplateLiteral(["uv"]))), {
  name: "UV",
  varying: true
});
var Vec3WithSpaceConversions = function Vec3WithSpaceConversions(expr, name) {
  return injectAPI(Vec3(expr, {
    name: name,
    varying: true
  }), function (unit) {
    return {
      get world() {
        return Vec3($localToWorldSpace(unit), {
          varying: true,
          name: "".concat(name, " (World Space)")
        });
      },
      get view() {
        return Vec3($localToViewSpace(unit), {
          varying: true,
          name: "".concat(name, " (View Space)")
        });
      }
    };
  });
};
var VertexPosition = Vec3WithSpaceConversions($(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral(["position"]))), "Vertex Position");
var VertexNormal = Vec3WithSpaceConversions($(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral(["normal"]))), "Vertex Normal");
var ViewDirection = Vec3($(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral(["vec3(-", "[0][2], -", "[1][2], -", "[2][2])"])), ViewMatrix, ViewMatrix, ViewMatrix), {
  varying: true,
  name: "View Direction"
});
var IsFrontFacing = Bool($(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral(["gl_FrontFacing"]))), {
  only: "fragment"
});
var Attribute = function Attribute(type, name) {
  return Unit(type, $(_templateObject17 || (_templateObject17 = _taggedTemplateLiteral(["", ""])), name), {
    name: "Attribute: ".concat(name),
    varying: true,
    vertex: {
      header: $(_templateObject18 || (_templateObject18 = _taggedTemplateLiteral(["attribute ", " ", ";"])), type, name)
    }
  });
};
var UniformUnit = function UniformUnit(type, initialValue, extras) {
  var uniform = {
    value: initialValue
  };

  /* Create the actual unit that represents the uniform. */
  var unit = Unit(type, undefined, _objectSpread2(_objectSpread2({
    name: "Uniform (".concat(type, ")")
  }, extras), {}, {
    uniform: uniform
  }));

  /* Return the unit with some API bits mixed in. */
  return injectAPI(unit, function () {
    return {
      set value(v) {
        uniform.value = v;
      },
      get value() {
        return uniform.value;
      }
    };
  });
};

/**
 * Provides a uniform unit holding a representation of time. The time value
 * stored is not an absolute time, so multiple instances of this unit will not
 * be synchronized. If you require synchronization, please either reuse the
 * same instance of this unit, or use `GlobalTime` instead.
 *
 * @param initial The initial time value to start with. (Default: 0)
 */
var Time = function Time() {
  var initial = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var uniform = UniformUnit("float", initial, {
    name: "Time Uniform",
    update: function update(dt) {
      uniform.value += dt;
    }
  });
  return uniform;
};

/**
 * A global time uniform unit that can be safely used across multiple shaders,
 * wherever synchronization is required,
 * and as a default value for `time` inputs of other unit implementations, to prevent
 * shaders from being spammed by multiple uniforms all holding different
 * representations of time.
 */
var GlobalTime = Time();
var Resolution = UniformUnit("vec2", new Vector2(0, 0), {
  name: "Current Render Resolution",
  update: function update(dt, camera, scene, gl) {
    Resolution.value.x = gl.domElement.width;
    Resolution.value.y = gl.domElement.height;
  }
});
var CameraNear = UniformUnit("float", 0, {
  name: "Camera Near Plane",
  update: function update(_, camera) {
    if (camera instanceof PerspectiveCamera) {
      CameraNear.value = camera.near;
    }
  }
});
var CameraFar = UniformUnit("float", 0, {
  name: "Camera Far Plane",
  update: function update(_, camera) {
    if (camera instanceof PerspectiveCamera) {
      CameraFar.value = camera.far;
    }
  }
});
var ScreenUV = Vec2($(_templateObject19 || (_templateObject19 = _taggedTemplateLiteral(["", " / ", ""])), FragmentCoordinate, Resolution), {
  name: "Screen UV"
});

var _templateObject$7, _templateObject2$5, _templateObject3$4, _templateObject4$3, _templateObject5$1, _templateObject6$1, _templateObject7$1, _templateObject8$1;
var $orthogonal = function $orthogonal(v) {
  return $ /*glsl*/(_templateObject$7 || (_templateObject$7 = _taggedTemplateLiteral(["\n  normalize(\n    abs(", ".x) > abs(", ".z)\n    ? vec3( -", ".y, ", ".x, 0.0 )\n    : vec3( 0.0, -", ".z, ", ".y)\n  )"])), v, v, v, v, v, v);
};

/**
 * Returns the normalized (unit length) version of a given vector.
 *
 * @param a The vec2/3/4 input value to normalize.
 * @returns A new Shader Unit containing the normalized value of `a`.
 */
var Normalize = function Normalize(a) {
  return Unit(type(a), $(_templateObject2$5 || (_templateObject2$5 = _taggedTemplateLiteral(["normalize(", ")"])), a), {
    name: "Normalize"
  });
};
var Cross = function Cross(a, b) {
  return Vec3($(_templateObject3$4 || (_templateObject3$4 = _taggedTemplateLiteral(["cross(", ", ", ")"])), a, b), {
    name: "Cross Product"
  });
};
var Dot = function Dot(a, b) {
  return Float($(_templateObject4$3 || (_templateObject4$3 = _taggedTemplateLiteral(["dot(", ", ", ")"])), a, b), {
    name: "Dot Product"
  });
};
var Tangent = function Tangent(v) {
  return Vec3($orthogonal(v), {
    name: "Tangent"
  });
};
var Bitangent = function Bitangent(p, t) {
  return Vec3(Normalize(Cross(p, t)), {
    name: "Bitangent"
  });
};
var Distance = function Distance(a, b) {
  return Float($(_templateObject5$1 || (_templateObject5$1 = _taggedTemplateLiteral(["distance(", ", ", ")"])), a, b), {
    name: "Distance"
  });
};
var Length = function Length(a) {
  return Float($(_templateObject6$1 || (_templateObject6$1 = _taggedTemplateLiteral(["length(", ")"])), a), {
    name: "Length"
  });
};
var Reflect = function Reflect(vector, normal) {
  return Unit(type(vector), $(_templateObject7$1 || (_templateObject7$1 = _taggedTemplateLiteral(["reflect(", ", ", ")"])), vector, normal), {
    name: "Reflect (".concat(type(vector), ")")
  });
};
var Refract = function Refract(vector, normal, eta) {
  return Unit(type(vector), $(_templateObject8$1 || (_templateObject8$1 = _taggedTemplateLiteral(["refract(", ", ", ", ", ")"])), vector, normal, eta), {
    name: "Refract (".concat(type(vector), ")")
  });
};

var _templateObject$6;
/**
 * A Shader Unit that calculates the fresnel effect.
 *
 * @param param0.normal The normal of the surface. Defaults to {@link VertexNormal}.
 * @param param0.alpha The alpha value of the fresnel effect. Defaults to 1.
 * @param param0.bias The bias of the fresnel effect. Defaults to 0.
 * @param param0.intensity The intensity of the fresnel effect. Defaults to 1.
 * @param param0.power The power of the fresnel effect. Defaults to 1.
 * @returns A shader unit holding the fresnel value.
 */
var Fresnel = function Fresnel() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    _ref$normal = _ref.normal,
    normal = _ref$normal === void 0 ? VertexNormal.world : _ref$normal,
    _ref$bias = _ref.bias,
    bias = _ref$bias === void 0 ? 0 : _ref$bias,
    _ref$intensity = _ref.intensity,
    intensity = _ref$intensity === void 0 ? 1 : _ref$intensity,
    _ref$power = _ref.power,
    power = _ref$power === void 0 ? 2 : _ref$power,
    _ref$factor = _ref.factor,
    factor = _ref$factor === void 0 ? 1 : _ref$factor;
  return Float(pipe(normal, function (v) {
    return Normalize(v);
  }, function (v) {
    return Dot(ViewDirection, v);
  }, function (v) {
    return Add(factor, v);
  }, function (v) {
    return Abs(v);
  }, function (v) {
    return Pow(v, power);
  }, function (v) {
    return Mul(v, intensity);
  }, function (v) {
    return Add(v, bias);
  }, function (v) {
    return Saturate(v);
  }), {
    name: "Fresnel"
  });
};
/**
 * A Shader Unit that returns the value of a gradient at a specified position.
 *
 * @param f The position within the gradient.
 * @param stops A configuration of value stops making up the gradient. See {@link GradientStops}.
 * @returns A shader unit holding the gradient value at the specified position.
 */
var Gradient = function Gradient(f) {
  for (var _len = arguments.length, stops = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    stops[_key - 1] = arguments[_key];
  }
  var color = stops[0][0];
  for (var i = 1; i < stops.length; i++) {
    var stop = stops[i];
    var previous = stops[i - 1];
    color = Lerp(color, stop[0], Smoothstep(previous[1], stop[1], f));
  }
  return color;
};
var Luminance = function Luminance(color) {
  return Float($(_templateObject$6 || (_templateObject$6 = _taggedTemplateLiteral(["luminance(", ")"])), color));
};

var _templateObject$5, _templateObject2$4;
var If = function If(expression, then, else_) {
  return Unit(type(then), $(_templateObject$5 || (_templateObject$5 = _taggedTemplateLiteral(["(", " ? ", " : ", ")"])), expression, then, else_));
};
var GreaterOrEqual = function GreaterOrEqual(a, b) {
  return Bool($(_templateObject2$4 || (_templateObject2$4 = _taggedTemplateLiteral(["(", " >= ", ")"])), a, b));
};

var _templateObject$4, _templateObject2$3, _templateObject3$3, _templateObject4$2, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12;
var ShaderMaterialMaster = function ShaderMaterialMaster() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    _ref$color = _ref.color,
    color = _ref$color === void 0 ? new Color("red") : _ref$color,
    _ref$alpha = _ref.alpha,
    alpha = _ref$alpha === void 0 ? 1 : _ref$alpha,
    _ref$position = _ref.position,
    position = _ref$position === void 0 ? VertexPosition : _ref$position;
  return Master({
    name: "ShaderMaterial Master",
    vertex: {
      body: $(_templateObject$4 || (_templateObject$4 = _taggedTemplateLiteral(["\n\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(", ", 1.0);\n\t\t\t"])), position)
    },
    fragment: {
      body: $(_templateObject2$3 || (_templateObject2$3 = _taggedTemplateLiteral(["\n\t\t\t\tgl_FragColor = vec4(", ", ", ");\n\t\t\t"])), color, alpha)
    }
  });
};
var CustomShaderMaterialMaster = function CustomShaderMaterialMaster() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    position = _ref2.position,
    normal = _ref2.normal,
    diffuseColor = _ref2.diffuseColor,
    emissiveColor = _ref2.emissiveColor,
    fragColor = _ref2.fragColor,
    roughness = _ref2.roughness,
    metalness = _ref2.metalness,
    alpha = _ref2.alpha;
  return Master({
    name: "CustomShaderMaterial Master",
    vertex: {
      body: $(_templateObject3$3 || (_templateObject3$3 = _taggedTemplateLiteral(["\n\t\t\t\t", "\n\t\t\t\t", "\n\t\t\t"])), position !== undefined ? $(_templateObject4$2 || (_templateObject4$2 = _taggedTemplateLiteral(["csm_Position.xyz = ", ";"])), position) : "", normal !== undefined ? $(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["csm_Normal = ", ";"])), normal) : "")
    },
    fragment: {
      body: $(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral(["\n  \t\t\t", "\n\t\t\t\t", "\n\t\t\t\t", "\n\t\t\t\t", "\n\n        #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\n          ", "\n          ", "\n        #endif\n\t\t\t"])), alpha !== undefined ? $(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral(["csm_DiffuseColor.a = ", ";"])), alpha) : "", diffuseColor !== undefined ? $(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral(["csm_DiffuseColor.rgb = ", ";"])), diffuseColor) : "", emissiveColor !== undefined ? $(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral(["csm_Emissive = ", ";"])), emissiveColor) : "", fragColor !== undefined ? $(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral(["csm_FragColor = vec4(", ", ", ");"])), fragColor, alpha) : "", roughness !== undefined ? $(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral(["csm_Roughness = ", ";"])), roughness) : "", metalness !== undefined ? $(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral(["csm_Metalness = ", ";"])), metalness) : "")
    }
  });
};

var _templateObject$3, _templateObject2$2, _templateObject3$2, _templateObject4$1;
var rotation3d = Snippet(function (name) {
  return glsl(_templateObject$3 || (_templateObject$3 = _taggedTemplateLiteral(["\n\t\tmat4 ", "(vec3 axis, float angle) {\n\t\t\taxis = normalize(axis);\n\t\t\tfloat s = sin(angle);\n\t\t\tfloat c = cos(angle);\n\t\t\tfloat oc = 1.0 - c;\n\t\t\treturn mat4(\n\t\t\t\toc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n\t\t\t\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n\t\t\t\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n\t\t\t\t0.0,                                0.0,                                0.0,                                1.0\n\t\t\t);\n\t\t}\n\t"])), name);
});
var rotation3dX = Snippet(function (name) {
  return glsl(_templateObject2$2 || (_templateObject2$2 = _taggedTemplateLiteral(["\n\t\tmat3 ", "(float angle) {\n\t\t\tfloat s = sin(angle);\n\t\t\tfloat c = cos(angle);\n\t\t\treturn mat3(\n\t\t\t\t1.0, 0.0, 0.0,\n\t\t\t\t0.0, c, s,\n\t\t\t\t0.0, -s, c\n\t\t\t);\n\t\t}\n\t"])), name);
});
var rotation3dY = Snippet(function (name) {
  return glsl(_templateObject3$2 || (_templateObject3$2 = _taggedTemplateLiteral(["\n\t\tmat3 ", "(float angle) {\n\t\t\tfloat s = sin(angle);\n\t\t\tfloat c = cos(angle);\n\t\t\n\t\t\treturn mat3(\n\t\t\t\tc, 0.0, -s,\n\t\t\t\t0.0, 1.0, 0.0,\n\t\t\t\ts, 0.0, c\n\t\t\t);\n\t\t}\n\t"])), name);
});
var rotation3dZ = Snippet(function (name) {
  return glsl(_templateObject4$1 || (_templateObject4$1 = _taggedTemplateLiteral(["\n\t\tmat3 ", "(float angle) {\n\t\t\tfloat s = sin(angle);\n\t\t\tfloat c = cos(angle);\n\t\t\n\t\t\treturn mat3(\n\t\t\t\tc, s, 0.0,\n\t\t\t\t-s, c, 0.0,\n\t\t\t\t0.0, 0.0, 1.0\n\t\t\t);\n\t\t}\n\t"])), name);
});

var _templateObject$2, _templateObject2$1, _templateObject3$1, _templateObject4;

/**
 * Generates a Shader Unit of type `mat4` representing a rotation around a specified
 * axis, by a specified amount/angle. This unit can then be multiplied with a
 * `vec3` unit in order to apply the rotation to that vector.
 *
 * @param axis Axis to rotate around.
 * @param angle The angle (amount) to rotate.
 * @returns A Shader Unit of type `mat4` representing the rotation matrix.
 */
var Rotation3D = function Rotation3D(axis, angle) {
  return Mat4($(_templateObject$2 || (_templateObject$2 = _taggedTemplateLiteral(["", "(", ", ", ")"])), rotation3d, axis, angle));
};
var Rotation3DX = function Rotation3DX(angle) {
  return Mat3($(_templateObject2$1 || (_templateObject2$1 = _taggedTemplateLiteral(["", "(", ")"])), rotation3dX, angle));
};
var Rotation3DY = function Rotation3DY(angle) {
  return Mat3($(_templateObject3$1 || (_templateObject3$1 = _taggedTemplateLiteral(["", "(", ")"])), rotation3dY, angle));
};
var Rotation3DZ = function Rotation3DZ(angle) {
  return Mat3($(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["", "(", ")"])), rotation3dZ, angle));
};

/**
 * Rotate a vector around the specified axis.
 *
 * @param position Vector to rotate.
 * @param axis The axis to rotate around.
 * @param angle The angle (amount) to rotate around the axis.
 * @returns A `vec3` Shader Unit containing the rotated vector.
 */
var Rotate3D = function Rotate3D(position, axis, angle) {
  return Mul(position, $mat3(Rotation3D(axis, angle)));
};
var RotateX = function RotateX(position, angle) {
  return Mul(position, Rotation3DX(angle));
};
var RotateY = function RotateY(position, angle) {
  return Mul(position, Rotation3DY(angle));
};
var RotateZ = function RotateZ(position, angle) {
  return Mul(position, Rotation3DZ(angle));
};

var _templateObject$1, _templateObject2, _templateObject3;
var Texture2D = function Texture2D(sampler2D, xy) {
  var texture2D = Vec4($(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral(["texture2D(", ", ", ")"])), sampler2D, xy), {
    name: "Texture2D"
  });
  return _objectSpread2(_objectSpread2({}, texture2D), {}, {
    /** The color value sampled from the texture. */
    color: Vec3($(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["", ".rgb"])), texture2D), {
      name: "Texture2D Color"
    }),
    /** The alpha value sampled from the texture. */
    alpha: Float($(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["", ".a"])), texture2D), {
      name: "Texture2D Alpha"
    })
  });
};

var _templateObject;
var SceneColor = function SceneColor(uv, texture) {
  return Texture2D(texture, uv);
};

/**
 * Sample a depth texture and return the raw depth value.
 *
 * @param uv Screen UV
 * @param depthTexture Depth texture to sample
 * @returns Float unit containing the depth as stored in the texture
 */
var RawDepth = function RawDepth(uv, depthTexture) {
  return Float(Texture2D(depthTexture, uv).x, {
    name: "Read Depth from Depth Texture (Raw)"
  });
};

/**
 * Sample a depth texture and return the depth value in eye space units.
 *
 * @param xy Screen position
 * @param depthTexture Depth texture to sample
 * @param cameraNear Camera near plane (defaults to CameraNear)
 * @param cameraFar Camera far plane (defaults to CameraFar)
 * @returns Float unit containing the depth in eye space units
 */
var PerspectiveDepth = function PerspectiveDepth(xy, depthTexture) {
  var cameraNear = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : CameraNear;
  var cameraFar = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : CameraFar;
  return Float(pipe(xy, function (v) {
    return RawDepth(v, depthTexture);
  }, function (v) {
    return $(_templateObject || (_templateObject = _taggedTemplateLiteral(["perspectiveDepthToViewZ(", ", ", ", ", ")"])), v, cameraNear, cameraFar);
  }), {
    name: "Read Depth from Depth Texture (Eye Space)"
  });
};

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function () {};
      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var DEBUG = false;
var enableDebugging = function enableDebugging() {
  DEBUG = true;
};
var disableDebugging = function disableDebugging() {
  DEBUG = false;
};

/**
 * Given a root unit, iterate over the tree and invoke the given callback for each
 * item encountered. Items include units, expressions, snippets, and any constant
 * values.
 *
 * @param item The root of the tree to traverse.
 * @param callback The callback to execute for each item.
 */
var walkTree = function walkTree(item, program, callback) {
  var seen = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Set();
  /* Visit each item only once */
  if (seen.has(item)) return;
  seen.add(item);

  /* Dive into dependencies */
  for (var _i = 0, _getDependencies = getDependencies(item, program); _i < _getDependencies.length; _i++) {
    var dependency = _getDependencies[_i];
    walkTree(dependency, program, callback, seen);
  }

  /* Invoke callback */
  callback(item);
};

/**
 * Walks the tree and returns all items found where the given callback function
 * returns true.
 */
var collectFromTree = function collectFromTree(root, program, check) {
  var found = new Array();
  walkTree(root, program, function (item) {
    if (check !== undefined ? check(item) : true) {
      found.push(item);
    }
  });
  return found;
};

/**
 * Given a unit, expression o snippet, returns that item's dependencies.
 *
 * @param item
 * @returns
 */
var getDependencies = function getDependencies(item, program) {
  var dependencies = isUnit(item) ? getUnitDependencies(item, program) : isExpression(item) ? item.values : isSnippet(item) ? item.expression.values : [];
  return dependencies.flat(Infinity).filter(dependencyFilter);
};
var getUnitDependencies = function getUnitDependencies(_ref, program) {
  var _config$vertex, _config$vertex$header, _config$vertex2, _config$vertex2$body, _config$fragment, _config$fragment$head, _config$fragment2, _config$fragment2$bod;
  var config = _ref._unitConfig;
  var dependencies = new Array();
  if (!config.varying || program === "any" || program === "vertex") dependencies.push(config.value);
  if (program === "any" || program === "vertex") dependencies.push((_config$vertex = config.vertex) === null || _config$vertex === void 0 ? void 0 : (_config$vertex$header = _config$vertex.header) === null || _config$vertex$header === void 0 ? void 0 : _config$vertex$header.values, (_config$vertex2 = config.vertex) === null || _config$vertex2 === void 0 ? void 0 : (_config$vertex2$body = _config$vertex2.body) === null || _config$vertex2$body === void 0 ? void 0 : _config$vertex2$body.values);
  if (program === "any" || program === "fragment") dependencies.push((_config$fragment = config.fragment) === null || _config$fragment === void 0 ? void 0 : (_config$fragment$head = _config$fragment.header) === null || _config$fragment$head === void 0 ? void 0 : _config$fragment$head.values, (_config$fragment2 = config.fragment) === null || _config$fragment2 === void 0 ? void 0 : (_config$fragment2$bod = _config$fragment2.body) === null || _config$fragment2$bod === void 0 ? void 0 : _config$fragment2$bod.values);
  return dependencies.filter(dependencyFilter);
};
var dependencyFilter = function dependencyFilter(item) {
  return !!item;
};

var idGenerator = (function () {
  var initial = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return function () {
    return ++initial;
  };
});

var beginUnit = function beginUnit(unit) {
  return "/*** UNIT: ".concat(unit._unitConfig.name, " ***/");
};
var endUnit = function endUnit(unit) {
  return "\n";
};
var compileItem = function compileItem(item, program, state) {
  if (state.seen.has(item)) return;
  state.seen.add(item);

  /* If the item is something we know, delegate to the corresponding function */
  if (isUnit(item)) compileUnit(item, program, state);else if (isSnippet(item)) compileSnippet(item, program, state);
};
var compileSnippet = function compileSnippet(snippet, program, state) {
  /* Add snippet to header */
  state.header.push(snippet.expression);
};
var compileUnit = function compileUnit(unit, program, state) {
  var _unit$_unitConfig$pro, _state$header, _unit$_unitConfig$pro3, _unit$_unitConfig$pro4;
  /* As a sanity check, check if the unit is even allowed to be compiled into
  the requested program. */
  if (!isUnitInProgram(unit, program)) {
    throw new Error(program === "vertex" ? "Encountered a unit \"".concat(unit._unitConfig.name, "\" that is only allowed in the fragment shader, but was encountered when compiling the vertex shader. Please check your unit connections.") : "Encountered a unit \"".concat(unit._unitConfig.name, "\" that is only allowed in the vertex shader, but was encountered when compiling the fragment shader. Consider wrapping the value, or the derived value you're interested in, in a Unit that has a varying."));
  }

  /* HEADER */
  var header = new Array();

  /* Declare varying if this unit has varying mode */
  if (unit._unitConfig.varying) {
    header.push(statement(unit._unitConfig.varying === "flat" ? "flat" : undefined, "varying", unit._unitConfig.type, "v_".concat(unit._unitConfig.variableName)));
  }

  /* Declare uniform, if one is configured. */
  if (unit._unitConfig.uniform) {
    /* Declare uniforms in header */
    header.push(statement("uniform", unit._unitConfig.type, uniformName(unit)));
  }

  /* Add header if present */
  if ((_unit$_unitConfig$pro = unit._unitConfig[program]) !== null && _unit$_unitConfig$pro !== void 0 && _unit$_unitConfig$pro.header) {
    var _unit$_unitConfig$pro2;
    header.push((_unit$_unitConfig$pro2 = unit._unitConfig[program]) === null || _unit$_unitConfig$pro2 === void 0 ? void 0 : _unit$_unitConfig$pro2.header);
  }
  if (header.length) (_state$header = state.header).push.apply(_state$header, [beginUnit(unit)].concat(header, [endUnit()]));

  /* BODY */

  var value = unit._unitConfig.varying && program === "fragment" ? "v_".concat(unit._unitConfig.variableName) : unit._unitConfig.uniform ? uniformName(unit) : glslRepresentation(unit._unitConfig.value, unit._unitConfig.type);
  state.body.push(beginUnit(unit));

  /*
  Declare the unit's global variable, and assign the specified value to it.
  */
  if (!unit._unitConfig.uniform) {
    state.body.push(statement(unit._unitConfig.type, unit._unitConfig.variableName, "=", value));
  }

  /*
  If a body chunk is given, we'll create a scoped block with a local variable called
  "value" that the chunk can modify before it is assigned back to the unit's global.
  */
  if ((_unit$_unitConfig$pro3 = unit._unitConfig[program]) !== null && _unit$_unitConfig$pro3 !== void 0 && _unit$_unitConfig$pro3.body) state.body.push(block( /* Declare local value variable */
  !unit._unitConfig.uniform && statement(unit._unitConfig.type, "value", "=", unit._unitConfig.variableName), /* Include body chunk */(_unit$_unitConfig$pro4 = unit._unitConfig[program]) === null || _unit$_unitConfig$pro4 === void 0 ? void 0 : _unit$_unitConfig$pro4.body, /* Re-assign local value variable to global variable */
  !unit._unitConfig.uniform && assignment(unit._unitConfig.variableName, "value")));

  /*
  If we're in varying mode and vertex, write value to the varying, too.
  */
  if (!unit._unitConfig.uniform && unit._unitConfig.varying && program === "vertex") {
    state.body.push(assignment("v_".concat(unit._unitConfig.variableName), unit._unitConfig.variableName));
  }
  state.body.push(endUnit());
};
var prepareItem = function prepareItem(item, nextId) {
  /* Prepare this unit */
  if (isUnit(item)) {
    /* Assign a variable name */
    item._unitConfig.variableName = identifier(sluggify(item._unitConfig.name), nextId());
    return;
  }

  /* Is it a snippet? */
  if (isSnippet(item)) {
    renameSnippet(item, "snippet_".concat(nextId()));
    return;
  }
};
var compileProgram = function compileProgram(unit, program, state) {
  walkTree(unit, program, function (item) {
    return compileItem(item, program, state);
  });
  return concatenate("/*** PROGRAM: ".concat(program.toUpperCase(), " ***/\n"), "precision highp float;\n", state.header, "void main()", block(state.body));
};
var compileShader = function compileShader(root) {
  /* STEP 1: prepare all units and their dependencies! */
  var nextId = idGenerator();
  walkTree(root, "any", function (item) {
    return prepareItem(item, nextId);
  });

  /*
  STEP 2: compile the fragment shader. We're going to compile it first because
  we need to identify units with varyings, because we will _always_ want to
  include them in the vertex shader.
  */
  var fragmentState = CompilerState();
  var fragmentShader = compileProgram(root, "fragment", fragmentState);

  /*
  STEP 3: compile the vertex shader. But first, we'll manually squeeze in all
  units with varyings.
  */
  var vertexState = CompilerState();

  /* Explicitly add all units with varyings. */
  fragmentState.seen.forEach(function (item) {
    if (isUnit(item) && item._unitConfig.varying) {
      walkTree(item, "vertex", function (item) {
        return compileItem(item, "vertex", vertexState);
      });
    }
  });

  /* Compile! */
  var vertexShader = compileProgram(root, "vertex", vertexState);

  /*
  STEP 4: Collect uniforms.
  */
  var unitsWithUniforms = collectFromTree(root, "any", function (item) {
    return isUnit(item) && !!item._unitConfig.uniform;
  });
  var uniforms = unitsWithUniforms.reduce(function (acc, unit) {
    return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty({}, uniformName(unit), unit._unitConfig.uniform));
  }, {});

  /*
  STEP 5: Collect update callbacks.
  */
  var unitsWithUpdates = collectFromTree(root, "any", function (item) {
    return isUnit(item) && !!item._unitConfig.update;
  });

  /*
  STEP 6: Build per-frame update function.
  */
  var update = function update(dt, camera, scene, gl) {
    var now = performance.now();
    var _iterator = _createForOfIteratorHelper(unitsWithUpdates),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var unit = _step.value;
        var state = unit._unitState;

        /* Only invoke the update callback once per frame. */
        if (state.lastUpdateAt === undefined || state.lastUpdateAt < now) {
          unit._unitConfig.update(dt, camera, scene, gl);
          state.lastUpdateAt = now;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  };

  /* Build a dispose function */
  var allUnits = collectFromTree(root, "any", isUnit);
  var dispose = function dispose() {
    return allUnits.forEach(function (u) {
      var _u$_unitConfig$dispos, _u$_unitConfig;
      return (_u$_unitConfig$dispos = (_u$_unitConfig = u._unitConfig).dispose) === null || _u$_unitConfig$dispos === void 0 ? void 0 : _u$_unitConfig$dispos.call(_u$_unitConfig);
    });
  };

  /*
  DONE! Let's return everything and go on a lengthy vacation somewhere nice.
  */
  var shader = {
    vertexShader: vertexShader,
    fragmentShader: fragmentShader,
    uniforms: uniforms
  };
  var meta = {
    update: update,
    dispose: dispose
  };
  if (DEBUG) {
    console.debug("[SC] Compiled shader");
  }
  return [shader, meta];
};
var CompilerState = function CompilerState() {
  return {
    header: new Array(),
    body: new Array(),
    nextid: idGenerator(),
    seen: new Set()
  };
};

export { $localToViewSpace, $localToWorldSpace, $orthogonal, Attribute, Bitangent, CameraFar, CameraNear, CameraPosition, Cross, CustomShaderMaterialMaster, Distance, Dot, FragmentCoordinate, Fresnel, GlobalTime, Gradient, GreaterOrEqual, If, InstanceID, InstanceMatrix, IsFrontFacing, Length, LocalToViewSpace, LocalToWorldSpace, Luminance, ModelMatrix, ModelViewMatrix, NormalMatrix, Normalize, PerspectiveDepth, ProjectionMatrix, RawDepth, Reflect, Refract, Resolution, Rotate3D, RotateX, RotateY, RotateZ, Rotation3D, Rotation3DX, Rotation3DY, Rotation3DZ, SceneColor, ScreenUV, ShaderMaterialMaster, Tangent, Texture2D, Time, UV, UniformUnit, UsingInstancing, VertexID, VertexNormal, VertexPosition, ViewDirection, ViewMatrix, collectFromTree, compileShader, disableDebugging, enableDebugging, getDependencies, walkTree };
